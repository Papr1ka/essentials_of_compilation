
# source program: add

    print((40 + 2))

Module([  Expr(Call(Name('print'), [BinOp(Constant(40), Add(), Constant(2))]))])


# type checking source program


# partial_eval

    print(42)

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/add


# shrink

    print(42)

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/add


# remove_complex_operands

    print(42)
Module([  Expr(Call(Name('print'), [Constant(42)]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/add


# explicate_control

start:
    print(42)
    return 0

CProgram(body={'start': [  Expr(Call(Name('print'), [Constant(42)])),   Return(Constant(0))]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/add


# select_instructions

	.align 16
conclusion:


	.align 16
start:
    movq $42, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/add


# remove_jumps

	.align 16
conclusion:


	.align 16
start:
    movq $42, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/add


# assign_homes

	.align 16
conclusion:


	.align 16
start:
    movq $42, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/add


# patch_instructions

	.align 16
conclusion:


	.align 16
start:
    movq $42, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/add


# prelude_and_conclusion

	.align 16
conclusion:
    popq %rbp
    retq 

	.align 16
start:
    movq $42, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.globl main
	.align 16
main:
    pushq %rbp
    movq %rsp, %rbp
    jmp start





# source program: input

    print(input_int())

Module([  Expr(Call(Name('print'), [Call(Name('input_int'), [])]))])


# type checking source program


# partial_eval

    print(input_int())

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/input


# shrink

    print(input_int())

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/input


# remove_complex_operands

    tmp.0 = input_int()
    print(tmp.0)
Module([  Assign([Name('tmp.0')], Call(Name('input_int'), [])),   Expr(Call(Name('print'), [Name('tmp.0')]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/input


# explicate_control

start:
    tmp.0 = input_int()
    print(tmp.0)
    return 0

CProgram(body={'start': [  Assign([Name('tmp.0')], Call(Name('input_int'), [])),   Expr(Call(Name('print'), [Name('tmp.0')])),   Return(Constant(0))]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/input


# select_instructions

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, tmp.0
    movq tmp.0, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/input


# remove_jumps

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, tmp.0
    movq tmp.0, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/input


# assign_homes

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, %rcx
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/input


# patch_instructions

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, %rcx
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/input


# prelude_and_conclusion

	.align 16
conclusion:
    popq %rbp
    retq 

	.align 16
start:
    callq read_int
    movq %rax, %rcx
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.globl main
	.align 16
main:
    pushq %rbp
    movq %rsp, %rbp
    jmp start





# source program: sub-input

    print((input_int() - input_int()))

Module([  Expr(Call(Name('print'), [BinOp(Call(Name('input_int'), []), Sub(), Call(Name('input_int'), []))]))])


# type checking source program


# partial_eval

    print((input_int() - input_int()))

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/sub-input


# shrink

    print((input_int() - input_int()))

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/sub-input


# remove_complex_operands

    tmp.1 = input_int()
    tmp.2 = input_int()
    tmp.3 = (tmp.1 - tmp.2)
    print(tmp.3)
Module([  Assign([Name('tmp.1')], Call(Name('input_int'), [])),   Assign([Name('tmp.2')], Call(Name('input_int'), [])),   Assign([Name('tmp.3')], BinOp(Name('tmp.1'), Sub(), Name('tmp.2'))),   Expr(Call(Name('print'), [Name('tmp.3')]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/sub-input


# explicate_control

start:
    tmp.1 = input_int()
    tmp.2 = input_int()
    tmp.3 = (tmp.1 - tmp.2)
    print(tmp.3)
    return 0

CProgram(body={'start': [  Assign([Name('tmp.1')], Call(Name('input_int'), [])),   Assign([Name('tmp.2')], Call(Name('input_int'), [])),   Assign([Name('tmp.3')], BinOp(Name('tmp.1'), Sub(), Name('tmp.2'))),   Expr(Call(Name('print'), [Name('tmp.3')])),   Return(Constant(0))]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/sub-input


# select_instructions

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, tmp.1
    callq read_int
    movq %rax, tmp.2
    movq tmp.1, tmp.3
    subq tmp.2, tmp.3
    movq tmp.3, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/sub-input


# remove_jumps

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, tmp.1
    callq read_int
    movq %rax, tmp.2
    movq tmp.1, tmp.3
    subq tmp.2, tmp.3
    movq tmp.3, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/sub-input


# assign_homes

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, %rbx
    callq read_int
    movq %rax, %rcx
    movq %rbx, %rbx
    subq %rcx, %rbx
    movq %rbx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/sub-input


# patch_instructions

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, %rbx
    callq read_int
    movq %rax, %rcx
    subq %rcx, %rbx
    movq %rbx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/sub-input


# prelude_and_conclusion

	.align 16
conclusion:
    addq $8, %rsp
    popq %rbx
    popq %rbp
    retq 

	.align 16
start:
    callq read_int
    movq %rax, %rbx
    callq read_int
    movq %rax, %rcx
    subq %rcx, %rbx
    movq %rbx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.globl main
	.align 16
main:
    pushq %rbp
    pushq %rbx
    movq %rsp, %rbp
    subq $8, %rsp
    jmp start





# source program: zero

    print(0)

Module([  Expr(Call(Name('print'), [Constant(0)]))])


# type checking source program


# partial_eval

    print(0)

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/zero


# shrink

    print(0)

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/zero


# remove_complex_operands

    print(0)
Module([  Expr(Call(Name('print'), [Constant(0)]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/zero


# explicate_control

start:
    print(0)
    return 0

CProgram(body={'start': [  Expr(Call(Name('print'), [Constant(0)])),   Return(Constant(0))]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/zero


# select_instructions

	.align 16
conclusion:


	.align 16
start:
    movq $0, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/zero


# remove_jumps

	.align 16
conclusion:


	.align 16
start:
    movq $0, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/zero


# assign_homes

	.align 16
conclusion:


	.align 16
start:
    movq $0, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/zero


# patch_instructions

	.align 16
conclusion:


	.align 16
start:
    movq $0, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/zero


# prelude_and_conclusion

	.align 16
conclusion:
    popq %rbp
    retq 

	.align 16
start:
    movq $0, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.globl main
	.align 16
main:
    pushq %rbp
    movq %rsp, %rbp
    jmp start





# source program: test_large_numbers

    a = input_int()
    b = 71854
    c = input_int()
    d = ((a + b) + c)
    print(d)
    g = a
    a = (b + c)
    print(a)
    print((c - g))

Module([  Assign([Name('a')], Call(Name('input_int'), [])),   Assign([Name('b')], Constant(71854)),   Assign([Name('c')], Call(Name('input_int'), [])),   Assign([Name('d')], BinOp(BinOp(Name('a'), Add(), Name('b')), Add(), Name('c'))),   Expr(Call(Name('print'), [Name('d')])),   Assign([Name('g')], Name('a')),   Assign([Name('a')], BinOp(Name('b'), Add(), Name('c'))),   Expr(Call(Name('print'), [Name('a')])),   Expr(Call(Name('print'), [BinOp(Name('c'), Sub(), Name('g'))]))])


# type checking source program


# partial_eval

    a = input_int()
    b = 71854
    c = input_int()
    d = ((a + b) + c)
    print(d)
    g = a
    a = (b + c)
    print(a)
    print((c - g))

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_large_numbers


# shrink

    a = input_int()
    b = 71854
    c = input_int()
    d = ((a + b) + c)
    print(d)
    g = a
    a = (b + c)
    print(a)
    print((c - g))

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_large_numbers


# remove_complex_operands

    a = input_int()
    b = 71854
    c = input_int()
    tmp.4 = (a + b)
    d = (tmp.4 + c)
    print(d)
    g = a
    a = (b + c)
    print(a)
    tmp.5 = (c - g)
    print(tmp.5)
Module([  Assign([Name('a')], Call(Name('input_int'), [])),   Assign([Name('b')], Constant(71854)),   Assign([Name('c')], Call(Name('input_int'), [])),   Assign([Name('tmp.4')], BinOp(Name('a'), Add(), Name('b'))),   Assign([Name('d')], BinOp(Name('tmp.4'), Add(), Name('c'))),   Expr(Call(Name('print'), [Name('d')])),   Assign([Name('g')], Name('a')),   Assign([Name('a')], BinOp(Name('b'), Add(), Name('c'))),   Expr(Call(Name('print'), [Name('a')])),   Assign([Name('tmp.5')], BinOp(Name('c'), Sub(), Name('g'))),   Expr(Call(Name('print'), [Name('tmp.5')]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_large_numbers


# explicate_control

start:
    a = input_int()
    b = 71854
    c = input_int()
    tmp.4 = (a + b)
    d = (tmp.4 + c)
    print(d)
    g = a
    a = (b + c)
    print(a)
    tmp.5 = (c - g)
    print(tmp.5)
    return 0

CProgram(body={'start': [  Assign([Name('a')], Call(Name('input_int'), [])),   Assign([Name('b')], Constant(71854)),   Assign([Name('c')], Call(Name('input_int'), [])),   Assign([Name('tmp.4')], BinOp(Name('a'), Add(), Name('b'))),   Assign([Name('d')], BinOp(Name('tmp.4'), Add(), Name('c'))),   Expr(Call(Name('print'), [Name('d')])),   Assign([Name('g')], Name('a')),   Assign([Name('a')], BinOp(Name('b'), Add(), Name('c'))),   Expr(Call(Name('print'), [Name('a')])),   Assign([Name('tmp.5')], BinOp(Name('c'), Sub(), Name('g'))),   Expr(Call(Name('print'), [Name('tmp.5')])),   Return(Constant(0))]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_large_numbers


# select_instructions

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, a
    movq $71854, b
    callq read_int
    movq %rax, c
    movq a, tmp.4
    addq b, tmp.4
    movq tmp.4, d
    addq c, d
    movq d, %rdi
    callq print_int
    movq a, g
    movq b, a
    addq c, a
    movq a, %rdi
    callq print_int
    movq c, tmp.5
    subq g, tmp.5
    movq tmp.5, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_large_numbers


# remove_jumps

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, a
    movq $71854, b
    callq read_int
    movq %rax, c
    movq a, tmp.4
    addq b, tmp.4
    movq tmp.4, d
    addq c, d
    movq d, %rdi
    callq print_int
    movq a, g
    movq b, a
    addq c, a
    movq a, %rdi
    callq print_int
    movq c, tmp.5
    subq g, tmp.5
    movq tmp.5, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_large_numbers


# assign_homes

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, %r12
    movq $71854, %rbx
    callq read_int
    movq %rax, %r13
    movq %r12, %rcx
    addq %rbx, %rcx
    movq %rcx, %rcx
    addq %r13, %rcx
    movq %rcx, %rdi
    callq print_int
    movq %r12, %r14
    movq %rbx, %r12
    addq %r13, %r12
    movq %r12, %rdi
    callq print_int
    movq %r13, %r13
    subq %r14, %r13
    movq %r13, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_large_numbers


# patch_instructions

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, %r12
    movq $71854, %rbx
    callq read_int
    movq %rax, %r13
    movq %r12, %rcx
    addq %rbx, %rcx
    addq %r13, %rcx
    movq %rcx, %rdi
    callq print_int
    movq %r12, %r14
    movq %rbx, %r12
    addq %r13, %r12
    movq %r12, %rdi
    callq print_int
    subq %r14, %r13
    movq %r13, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_large_numbers


# prelude_and_conclusion

	.align 16
conclusion:
    popq %r14
    popq %r13
    popq %r12
    popq %rbx
    popq %rbp
    retq 

	.align 16
start:
    callq read_int
    movq %rax, %r12
    movq $71854, %rbx
    callq read_int
    movq %rax, %r13
    movq %r12, %rcx
    addq %rbx, %rcx
    addq %r13, %rcx
    movq %rcx, %rdi
    callq print_int
    movq %r12, %r14
    movq %rbx, %r12
    addq %r13, %r12
    movq %r12, %rdi
    callq print_int
    subq %r14, %r13
    movq %r13, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.globl main
	.align 16
main:
    pushq %rbp
    pushq %rbx
    pushq %r12
    pushq %r13
    pushq %r14
    movq %rsp, %rbp
    jmp start





# source program: test_homes_trivial

    a = 42
    b = a
    print(b)

Module([  Assign([Name('a')], Constant(42)),   Assign([Name('b')], Name('a')),   Expr(Call(Name('print'), [Name('b')]))])


# type checking source program


# partial_eval

    a = 42
    b = a
    print(b)

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_homes_trivial


# shrink

    a = 42
    b = a
    print(b)

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_homes_trivial


# remove_complex_operands

    a = 42
    b = a
    print(b)
Module([  Assign([Name('a')], Constant(42)),   Assign([Name('b')], Name('a')),   Expr(Call(Name('print'), [Name('b')]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_homes_trivial


# explicate_control

start:
    a = 42
    b = a
    print(b)
    return 0

CProgram(body={'start': [  Assign([Name('a')], Constant(42)),   Assign([Name('b')], Name('a')),   Expr(Call(Name('print'), [Name('b')])),   Return(Constant(0))]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_homes_trivial


# select_instructions

	.align 16
conclusion:


	.align 16
start:
    movq $42, a
    movq a, b
    movq b, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_homes_trivial


# remove_jumps

	.align 16
conclusion:


	.align 16
start:
    movq $42, a
    movq a, b
    movq b, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_homes_trivial


# assign_homes

	.align 16
conclusion:


	.align 16
start:
    movq $42, %rcx
    movq %rcx, %rcx
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_homes_trivial


# patch_instructions

	.align 16
conclusion:


	.align 16
start:
    movq $42, %rcx
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_homes_trivial


# prelude_and_conclusion

	.align 16
conclusion:
    popq %rbp
    retq 

	.align 16
start:
    movq $42, %rcx
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.globl main
	.align 16
main:
    pushq %rbp
    movq %rsp, %rbp
    jmp start





# source program: one_big_number

    a = input_int()
    b = 91634
    print((b + a))

Module([  Assign([Name('a')], Call(Name('input_int'), [])),   Assign([Name('b')], Constant(91634)),   Expr(Call(Name('print'), [BinOp(Name('b'), Add(), Name('a'))]))])


# type checking source program


# partial_eval

    a = input_int()
    b = 91634
    print((b + a))

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/one_big_number


# shrink

    a = input_int()
    b = 91634
    print((b + a))

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/one_big_number


# remove_complex_operands

    a = input_int()
    b = 91634
    tmp.6 = (b + a)
    print(tmp.6)
Module([  Assign([Name('a')], Call(Name('input_int'), [])),   Assign([Name('b')], Constant(91634)),   Assign([Name('tmp.6')], BinOp(Name('b'), Add(), Name('a'))),   Expr(Call(Name('print'), [Name('tmp.6')]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/one_big_number


# explicate_control

start:
    a = input_int()
    b = 91634
    tmp.6 = (b + a)
    print(tmp.6)
    return 0

CProgram(body={'start': [  Assign([Name('a')], Call(Name('input_int'), [])),   Assign([Name('b')], Constant(91634)),   Assign([Name('tmp.6')], BinOp(Name('b'), Add(), Name('a'))),   Expr(Call(Name('print'), [Name('tmp.6')])),   Return(Constant(0))]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/one_big_number


# select_instructions

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, a
    movq $91634, b
    movq b, tmp.6
    addq a, tmp.6
    movq tmp.6, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/one_big_number


# remove_jumps

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, a
    movq $91634, b
    movq b, tmp.6
    addq a, tmp.6
    movq tmp.6, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/one_big_number


# assign_homes

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, %rdx
    movq $91634, %rcx
    movq %rcx, %rcx
    addq %rdx, %rcx
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/one_big_number


# patch_instructions

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, %rdx
    movq $91634, %rcx
    addq %rdx, %rcx
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/one_big_number


# prelude_and_conclusion

	.align 16
conclusion:
    popq %rbp
    retq 

	.align 16
start:
    callq read_int
    movq %rax, %rdx
    movq $91634, %rcx
    addq %rdx, %rcx
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.globl main
	.align 16
main:
    pushq %rbp
    movq %rsp, %rbp
    jmp start





# source program: check_partial_eval

    b = (48 - (100 + 4))
    a = (((2 + (5 - (6 + 7))) - 4) + b)
    print((a + b))

Module([  Assign([Name('b')], BinOp(Constant(48), Sub(), BinOp(Constant(100), Add(), Constant(4)))),   Assign([Name('a')], BinOp(BinOp(BinOp(Constant(2), Add(), BinOp(Constant(5), Sub(), BinOp(Constant(6), Add(), Constant(7)))), Sub(), Constant(4)), Add(), Name('b'))),   Expr(Call(Name('print'), [BinOp(Name('a'), Add(), Name('b'))]))])


# type checking source program


# partial_eval

    b = -56
    a = (-10 + b)
    print((a + b))

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/check_partial_eval


# shrink

    b = -56
    a = (-10 + b)
    print((a + b))

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/check_partial_eval


# remove_complex_operands

    b = -56
    a = (-10 + b)
    tmp.7 = (a + b)
    print(tmp.7)
Module([  Assign([Name('b')], Constant(-56)),   Assign([Name('a')], BinOp(Constant(-10), Add(), Name('b'))),   Assign([Name('tmp.7')], BinOp(Name('a'), Add(), Name('b'))),   Expr(Call(Name('print'), [Name('tmp.7')]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/check_partial_eval


# explicate_control

start:
    b = -56
    a = (-10 + b)
    tmp.7 = (a + b)
    print(tmp.7)
    return 0

CProgram(body={'start': [  Assign([Name('b')], Constant(-56)),   Assign([Name('a')], BinOp(Constant(-10), Add(), Name('b'))),   Assign([Name('tmp.7')], BinOp(Name('a'), Add(), Name('b'))),   Expr(Call(Name('print'), [Name('tmp.7')])),   Return(Constant(0))]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/check_partial_eval


# select_instructions

	.align 16
conclusion:


	.align 16
start:
    movq $-56, b
    movq $-10, a
    addq b, a
    movq a, tmp.7
    addq b, tmp.7
    movq tmp.7, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/check_partial_eval


# remove_jumps

	.align 16
conclusion:


	.align 16
start:
    movq $-56, b
    movq $-10, a
    addq b, a
    movq a, tmp.7
    addq b, tmp.7
    movq tmp.7, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/check_partial_eval


# assign_homes

	.align 16
conclusion:


	.align 16
start:
    movq $-56, %rcx
    movq $-10, %rdx
    addq %rcx, %rdx
    movq %rdx, %rdx
    addq %rcx, %rdx
    movq %rdx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/check_partial_eval


# patch_instructions

	.align 16
conclusion:


	.align 16
start:
    movq $-56, %rcx
    movq $-10, %rdx
    addq %rcx, %rdx
    addq %rcx, %rdx
    movq %rdx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/check_partial_eval


# prelude_and_conclusion

	.align 16
conclusion:
    popq %rbp
    retq 

	.align 16
start:
    movq $-56, %rcx
    movq $-10, %rdx
    addq %rcx, %rdx
    addq %rcx, %rdx
    movq %rdx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.globl main
	.align 16
main:
    pushq %rbp
    movq %rsp, %rbp
    jmp start





# source program: check_improved_partial_eval

    print((1 + (input_int() + 1)))
    print((5 - (input_int() + 2)))
    print(((1 + (1 + input_int())) + 1))
    print(((5 - 2) + (input_int() - 6)))

Module([  Expr(Call(Name('print'), [BinOp(Constant(1), Add(), BinOp(Call(Name('input_int'), []), Add(), Constant(1)))])),   Expr(Call(Name('print'), [BinOp(Constant(5), Sub(), BinOp(Call(Name('input_int'), []), Add(), Constant(2)))])),   Expr(Call(Name('print'), [BinOp(BinOp(Constant(1), Add(), BinOp(Constant(1), Add(), Call(Name('input_int'), []))), Add(), Constant(1))])),   Expr(Call(Name('print'), [BinOp(BinOp(Constant(5), Sub(), Constant(2)), Add(), BinOp(Call(Name('input_int'), []), Sub(), Constant(6)))]))])


# type checking source program


# partial_eval

    print((2 + input_int()))
    print((3 - input_int()))
    print((3 + input_int()))
    print((3 + (input_int() - 6)))

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/check_improved_partial_eval


# shrink

    print((2 + input_int()))
    print((3 - input_int()))
    print((3 + input_int()))
    print((3 + (input_int() - 6)))

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/check_improved_partial_eval


# remove_complex_operands

    tmp.8 = input_int()
    tmp.9 = (2 + tmp.8)
    print(tmp.9)
    tmp.10 = input_int()
    tmp.11 = (3 - tmp.10)
    print(tmp.11)
    tmp.12 = input_int()
    tmp.13 = (3 + tmp.12)
    print(tmp.13)
    tmp.14 = input_int()
    tmp.15 = (tmp.14 - 6)
    tmp.16 = (3 + tmp.15)
    print(tmp.16)
Module([  Assign([Name('tmp.8')], Call(Name('input_int'), [])),   Assign([Name('tmp.9')], BinOp(Constant(2), Add(), Name('tmp.8'))),   Expr(Call(Name('print'), [Name('tmp.9')])),   Assign([Name('tmp.10')], Call(Name('input_int'), [])),   Assign([Name('tmp.11')], BinOp(Constant(3), Sub(), Name('tmp.10'))),   Expr(Call(Name('print'), [Name('tmp.11')])),   Assign([Name('tmp.12')], Call(Name('input_int'), [])),   Assign([Name('tmp.13')], BinOp(Constant(3), Add(), Name('tmp.12'))),   Expr(Call(Name('print'), [Name('tmp.13')])),   Assign([Name('tmp.14')], Call(Name('input_int'), [])),   Assign([Name('tmp.15')], BinOp(Name('tmp.14'), Sub(), Constant(6))),   Assign([Name('tmp.16')], BinOp(Constant(3), Add(), Name('tmp.15'))),   Expr(Call(Name('print'), [Name('tmp.16')]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/check_improved_partial_eval


# explicate_control

start:
    tmp.8 = input_int()
    tmp.9 = (2 + tmp.8)
    print(tmp.9)
    tmp.10 = input_int()
    tmp.11 = (3 - tmp.10)
    print(tmp.11)
    tmp.12 = input_int()
    tmp.13 = (3 + tmp.12)
    print(tmp.13)
    tmp.14 = input_int()
    tmp.15 = (tmp.14 - 6)
    tmp.16 = (3 + tmp.15)
    print(tmp.16)
    return 0

CProgram(body={'start': [  Assign([Name('tmp.8')], Call(Name('input_int'), [])),   Assign([Name('tmp.9')], BinOp(Constant(2), Add(), Name('tmp.8'))),   Expr(Call(Name('print'), [Name('tmp.9')])),   Assign([Name('tmp.10')], Call(Name('input_int'), [])),   Assign([Name('tmp.11')], BinOp(Constant(3), Sub(), Name('tmp.10'))),   Expr(Call(Name('print'), [Name('tmp.11')])),   Assign([Name('tmp.12')], Call(Name('input_int'), [])),   Assign([Name('tmp.13')], BinOp(Constant(3), Add(), Name('tmp.12'))),   Expr(Call(Name('print'), [Name('tmp.13')])),   Assign([Name('tmp.14')], Call(Name('input_int'), [])),   Assign([Name('tmp.15')], BinOp(Name('tmp.14'), Sub(), Constant(6))),   Assign([Name('tmp.16')], BinOp(Constant(3), Add(), Name('tmp.15'))),   Expr(Call(Name('print'), [Name('tmp.16')])),   Return(Constant(0))]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/check_improved_partial_eval


# select_instructions

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, tmp.8
    movq $2, tmp.9
    addq tmp.8, tmp.9
    movq tmp.9, %rdi
    callq print_int
    callq read_int
    movq %rax, tmp.10
    movq $3, tmp.11
    subq tmp.10, tmp.11
    movq tmp.11, %rdi
    callq print_int
    callq read_int
    movq %rax, tmp.12
    movq $3, tmp.13
    addq tmp.12, tmp.13
    movq tmp.13, %rdi
    callq print_int
    callq read_int
    movq %rax, tmp.14
    movq tmp.14, tmp.15
    subq $6, tmp.15
    movq $3, tmp.16
    addq tmp.15, tmp.16
    movq tmp.16, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/check_improved_partial_eval


# remove_jumps

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, tmp.8
    movq $2, tmp.9
    addq tmp.8, tmp.9
    movq tmp.9, %rdi
    callq print_int
    callq read_int
    movq %rax, tmp.10
    movq $3, tmp.11
    subq tmp.10, tmp.11
    movq tmp.11, %rdi
    callq print_int
    callq read_int
    movq %rax, tmp.12
    movq $3, tmp.13
    addq tmp.12, tmp.13
    movq tmp.13, %rdi
    callq print_int
    callq read_int
    movq %rax, tmp.14
    movq tmp.14, tmp.15
    subq $6, tmp.15
    movq $3, tmp.16
    addq tmp.15, tmp.16
    movq tmp.16, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/check_improved_partial_eval


# assign_homes

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, %rdx
    movq $2, %rcx
    addq %rdx, %rcx
    movq %rcx, %rdi
    callq print_int
    callq read_int
    movq %rax, %rdx
    movq $3, %rcx
    subq %rdx, %rcx
    movq %rcx, %rdi
    callq print_int
    callq read_int
    movq %rax, %rdx
    movq $3, %rcx
    addq %rdx, %rcx
    movq %rcx, %rdi
    callq print_int
    callq read_int
    movq %rax, %rcx
    movq %rcx, %rcx
    subq $6, %rcx
    movq $3, %rdx
    addq %rcx, %rdx
    movq %rdx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/check_improved_partial_eval


# patch_instructions

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, %rdx
    movq $2, %rcx
    addq %rdx, %rcx
    movq %rcx, %rdi
    callq print_int
    callq read_int
    movq %rax, %rdx
    movq $3, %rcx
    subq %rdx, %rcx
    movq %rcx, %rdi
    callq print_int
    callq read_int
    movq %rax, %rdx
    movq $3, %rcx
    addq %rdx, %rcx
    movq %rcx, %rdi
    callq print_int
    callq read_int
    movq %rax, %rcx
    subq $6, %rcx
    movq $3, %rdx
    addq %rcx, %rdx
    movq %rdx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/check_improved_partial_eval


# prelude_and_conclusion

	.align 16
conclusion:
    popq %rbp
    retq 

	.align 16
start:
    callq read_int
    movq %rax, %rdx
    movq $2, %rcx
    addq %rdx, %rcx
    movq %rcx, %rdi
    callq print_int
    callq read_int
    movq %rax, %rdx
    movq $3, %rcx
    subq %rdx, %rcx
    movq %rcx, %rdi
    callq print_int
    callq read_int
    movq %rax, %rdx
    movq $3, %rcx
    addq %rdx, %rcx
    movq %rcx, %rdi
    callq print_int
    callq read_int
    movq %rax, %rcx
    subq $6, %rcx
    movq $3, %rdx
    addq %rcx, %rdx
    movq %rdx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.globl main
	.align 16
main:
    pushq %rbp
    movq %rsp, %rbp
    jmp start





# source program: add_complex

    print((input_int() + -((5 + ((-(1) + 3) + 400)))))

Module([  Expr(Call(Name('print'), [BinOp(Call(Name('input_int'), []), Add(), UnaryOp(USub(), BinOp(Constant(5), Add(), BinOp(BinOp(UnaryOp(USub(), Constant(1)), Add(), Constant(3)), Add(), Constant(400)))))]))])


# type checking source program


# partial_eval

    print((-407 + input_int()))

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/add_complex


# shrink

    print((-407 + input_int()))

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/add_complex


# remove_complex_operands

    tmp.17 = input_int()
    tmp.18 = (-407 + tmp.17)
    print(tmp.18)
Module([  Assign([Name('tmp.17')], Call(Name('input_int'), [])),   Assign([Name('tmp.18')], BinOp(Constant(-407), Add(), Name('tmp.17'))),   Expr(Call(Name('print'), [Name('tmp.18')]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/add_complex


# explicate_control

start:
    tmp.17 = input_int()
    tmp.18 = (-407 + tmp.17)
    print(tmp.18)
    return 0

CProgram(body={'start': [  Assign([Name('tmp.17')], Call(Name('input_int'), [])),   Assign([Name('tmp.18')], BinOp(Constant(-407), Add(), Name('tmp.17'))),   Expr(Call(Name('print'), [Name('tmp.18')])),   Return(Constant(0))]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/add_complex


# select_instructions

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, tmp.17
    movq $-407, tmp.18
    addq tmp.17, tmp.18
    movq tmp.18, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/add_complex


# remove_jumps

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, tmp.17
    movq $-407, tmp.18
    addq tmp.17, tmp.18
    movq tmp.18, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/add_complex


# assign_homes

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, %rdx
    movq $-407, %rcx
    addq %rdx, %rcx
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/add_complex


# patch_instructions

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, %rdx
    movq $-407, %rcx
    addq %rdx, %rcx
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/add_complex


# prelude_and_conclusion

	.align 16
conclusion:
    popq %rbp
    retq 

	.align 16
start:
    callq read_int
    movq %rax, %rdx
    movq $-407, %rcx
    addq %rdx, %rcx
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.globl main
	.align 16
main:
    pushq %rbp
    movq %rsp, %rbp
    jmp start





# source program: add_to_input

    print((input_int() + 100))

Module([  Expr(Call(Name('print'), [BinOp(Call(Name('input_int'), []), Add(), Constant(100))]))])


# type checking source program


# partial_eval

    print((100 + input_int()))

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/add_to_input


# shrink

    print((100 + input_int()))

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/add_to_input


# remove_complex_operands

    tmp.19 = input_int()
    tmp.20 = (100 + tmp.19)
    print(tmp.20)
Module([  Assign([Name('tmp.19')], Call(Name('input_int'), [])),   Assign([Name('tmp.20')], BinOp(Constant(100), Add(), Name('tmp.19'))),   Expr(Call(Name('print'), [Name('tmp.20')]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/add_to_input


# explicate_control

start:
    tmp.19 = input_int()
    tmp.20 = (100 + tmp.19)
    print(tmp.20)
    return 0

CProgram(body={'start': [  Assign([Name('tmp.19')], Call(Name('input_int'), [])),   Assign([Name('tmp.20')], BinOp(Constant(100), Add(), Name('tmp.19'))),   Expr(Call(Name('print'), [Name('tmp.20')])),   Return(Constant(0))]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/add_to_input


# select_instructions

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, tmp.19
    movq $100, tmp.20
    addq tmp.19, tmp.20
    movq tmp.20, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/add_to_input


# remove_jumps

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, tmp.19
    movq $100, tmp.20
    addq tmp.19, tmp.20
    movq tmp.20, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/add_to_input


# assign_homes

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, %rdx
    movq $100, %rcx
    addq %rdx, %rcx
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/add_to_input


# patch_instructions

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, %rdx
    movq $100, %rcx
    addq %rdx, %rcx
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/add_to_input


# prelude_and_conclusion

	.align 16
conclusion:
    popq %rbp
    retq 

	.align 16
start:
    callq read_int
    movq %rax, %rdx
    movq $100, %rcx
    addq %rdx, %rcx
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.globl main
	.align 16
main:
    pushq %rbp
    movq %rsp, %rbp
    jmp start





# source program: complex_expr

    a = input_int()
    b = input_int()
    c = ((((((a + 4) - 2) + 6) - ((((b + 4) - 1) - 2) - 3)) + -(4)) + 1)
    print(c)

Module([  Assign([Name('a')], Call(Name('input_int'), [])),   Assign([Name('b')], Call(Name('input_int'), [])),   Assign([Name('c')], BinOp(BinOp(BinOp(BinOp(BinOp(BinOp(Name('a'), Add(), Constant(4)), Sub(), Constant(2)), Add(), Constant(6)), Sub(), BinOp(BinOp(BinOp(BinOp(Name('b'), Add(), Constant(4)), Sub(), Constant(1)), Sub(), Constant(2)), Sub(), Constant(3))), Add(), UnaryOp(USub(), Constant(4))), Add(), Constant(1))),   Expr(Call(Name('print'), [Name('c')]))])


# type checking source program


# partial_eval

    a = input_int()
    b = input_int()
    c = (-3 + ((8 + a) - (-2 + b)))
    print(c)

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/complex_expr


# shrink

    a = input_int()
    b = input_int()
    c = (-3 + ((8 + a) - (-2 + b)))
    print(c)

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/complex_expr


# remove_complex_operands

    a = input_int()
    b = input_int()
    tmp.21 = (8 + a)
    tmp.22 = (-2 + b)
    tmp.23 = (tmp.21 - tmp.22)
    c = (-3 + tmp.23)
    print(c)
Module([  Assign([Name('a')], Call(Name('input_int'), [])),   Assign([Name('b')], Call(Name('input_int'), [])),   Assign([Name('tmp.21')], BinOp(Constant(8), Add(), Name('a'))),   Assign([Name('tmp.22')], BinOp(Constant(-2), Add(), Name('b'))),   Assign([Name('tmp.23')], BinOp(Name('tmp.21'), Sub(), Name('tmp.22'))),   Assign([Name('c')], BinOp(Constant(-3), Add(), Name('tmp.23'))),   Expr(Call(Name('print'), [Name('c')]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/complex_expr


# explicate_control

start:
    a = input_int()
    b = input_int()
    tmp.21 = (8 + a)
    tmp.22 = (-2 + b)
    tmp.23 = (tmp.21 - tmp.22)
    c = (-3 + tmp.23)
    print(c)
    return 0

CProgram(body={'start': [  Assign([Name('a')], Call(Name('input_int'), [])),   Assign([Name('b')], Call(Name('input_int'), [])),   Assign([Name('tmp.21')], BinOp(Constant(8), Add(), Name('a'))),   Assign([Name('tmp.22')], BinOp(Constant(-2), Add(), Name('b'))),   Assign([Name('tmp.23')], BinOp(Name('tmp.21'), Sub(), Name('tmp.22'))),   Assign([Name('c')], BinOp(Constant(-3), Add(), Name('tmp.23'))),   Expr(Call(Name('print'), [Name('c')])),   Return(Constant(0))]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/complex_expr


# select_instructions

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, a
    callq read_int
    movq %rax, b
    movq $8, tmp.21
    addq a, tmp.21
    movq $-2, tmp.22
    addq b, tmp.22
    movq tmp.21, tmp.23
    subq tmp.22, tmp.23
    movq $-3, c
    addq tmp.23, c
    movq c, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/complex_expr


# remove_jumps

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, a
    callq read_int
    movq %rax, b
    movq $8, tmp.21
    addq a, tmp.21
    movq $-2, tmp.22
    addq b, tmp.22
    movq tmp.21, tmp.23
    subq tmp.22, tmp.23
    movq $-3, c
    addq tmp.23, c
    movq c, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/complex_expr


# assign_homes

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, %rbx
    callq read_int
    movq %rax, %rcx
    movq $8, %rdx
    addq %rbx, %rdx
    movq $-2, %rsi
    addq %rcx, %rsi
    movq %rdx, %rdx
    subq %rsi, %rdx
    movq $-3, %rcx
    addq %rdx, %rcx
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/complex_expr


# patch_instructions

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, %rbx
    callq read_int
    movq %rax, %rcx
    movq $8, %rdx
    addq %rbx, %rdx
    movq $-2, %rsi
    addq %rcx, %rsi
    subq %rsi, %rdx
    movq $-3, %rcx
    addq %rdx, %rcx
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/complex_expr


# prelude_and_conclusion

	.align 16
conclusion:
    addq $8, %rsp
    popq %rbx
    popq %rbp
    retq 

	.align 16
start:
    callq read_int
    movq %rax, %rbx
    callq read_int
    movq %rax, %rcx
    movq $8, %rdx
    addq %rbx, %rdx
    movq $-2, %rsi
    addq %rcx, %rsi
    subq %rsi, %rdx
    movq $-3, %rcx
    addq %rdx, %rcx
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.globl main
	.align 16
main:
    pushq %rbp
    pushq %rbx
    movq %rsp, %rbp
    subq $8, %rsp
    jmp start





# source program: fact

    a = 1
    a = (a + a)
    a = ((a + a) + a)
    b = (a + a)
    a = (b + b)
    b = (a + a)
    a = ((b + b) + a)
    print(a)

Module([  Assign([Name('a')], Constant(1)),   Assign([Name('a')], BinOp(Name('a'), Add(), Name('a'))),   Assign([Name('a')], BinOp(BinOp(Name('a'), Add(), Name('a')), Add(), Name('a'))),   Assign([Name('b')], BinOp(Name('a'), Add(), Name('a'))),   Assign([Name('a')], BinOp(Name('b'), Add(), Name('b'))),   Assign([Name('b')], BinOp(Name('a'), Add(), Name('a'))),   Assign([Name('a')], BinOp(BinOp(Name('b'), Add(), Name('b')), Add(), Name('a'))),   Expr(Call(Name('print'), [Name('a')]))])


# type checking source program


# partial_eval

    a = 1
    a = (a + a)
    a = ((a + a) + a)
    b = (a + a)
    a = (b + b)
    b = (a + a)
    a = ((b + b) + a)
    print(a)

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/fact


# shrink

    a = 1
    a = (a + a)
    a = ((a + a) + a)
    b = (a + a)
    a = (b + b)
    b = (a + a)
    a = ((b + b) + a)
    print(a)

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/fact


# remove_complex_operands

    a = 1
    a = (a + a)
    tmp.24 = (a + a)
    a = (tmp.24 + a)
    b = (a + a)
    a = (b + b)
    b = (a + a)
    tmp.25 = (b + b)
    a = (tmp.25 + a)
    print(a)
Module([  Assign([Name('a')], Constant(1)),   Assign([Name('a')], BinOp(Name('a'), Add(), Name('a'))),   Assign([Name('tmp.24')], BinOp(Name('a'), Add(), Name('a'))),   Assign([Name('a')], BinOp(Name('tmp.24'), Add(), Name('a'))),   Assign([Name('b')], BinOp(Name('a'), Add(), Name('a'))),   Assign([Name('a')], BinOp(Name('b'), Add(), Name('b'))),   Assign([Name('b')], BinOp(Name('a'), Add(), Name('a'))),   Assign([Name('tmp.25')], BinOp(Name('b'), Add(), Name('b'))),   Assign([Name('a')], BinOp(Name('tmp.25'), Add(), Name('a'))),   Expr(Call(Name('print'), [Name('a')]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/fact


# explicate_control

start:
    a = 1
    a = (a + a)
    tmp.24 = (a + a)
    a = (tmp.24 + a)
    b = (a + a)
    a = (b + b)
    b = (a + a)
    tmp.25 = (b + b)
    a = (tmp.25 + a)
    print(a)
    return 0

CProgram(body={'start': [  Assign([Name('a')], Constant(1)),   Assign([Name('a')], BinOp(Name('a'), Add(), Name('a'))),   Assign([Name('tmp.24')], BinOp(Name('a'), Add(), Name('a'))),   Assign([Name('a')], BinOp(Name('tmp.24'), Add(), Name('a'))),   Assign([Name('b')], BinOp(Name('a'), Add(), Name('a'))),   Assign([Name('a')], BinOp(Name('b'), Add(), Name('b'))),   Assign([Name('b')], BinOp(Name('a'), Add(), Name('a'))),   Assign([Name('tmp.25')], BinOp(Name('b'), Add(), Name('b'))),   Assign([Name('a')], BinOp(Name('tmp.25'), Add(), Name('a'))),   Expr(Call(Name('print'), [Name('a')])),   Return(Constant(0))]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/fact


# select_instructions

	.align 16
conclusion:


	.align 16
start:
    movq $1, a
    addq a, a
    movq a, tmp.24
    addq a, tmp.24
    addq tmp.24, a
    movq a, b
    addq a, b
    movq b, a
    addq b, a
    movq a, b
    addq a, b
    movq b, tmp.25
    addq b, tmp.25
    addq tmp.25, a
    movq a, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/fact


# remove_jumps

	.align 16
conclusion:


	.align 16
start:
    movq $1, a
    addq a, a
    movq a, tmp.24
    addq a, tmp.24
    addq tmp.24, a
    movq a, b
    addq a, b
    movq b, a
    addq b, a
    movq a, b
    addq a, b
    movq b, tmp.25
    addq b, tmp.25
    addq tmp.25, a
    movq a, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/fact


# assign_homes

	.align 16
conclusion:


	.align 16
start:
    movq $1, %rdx
    addq %rdx, %rdx
    movq %rdx, %rcx
    addq %rdx, %rcx
    addq %rcx, %rdx
    movq %rdx, %rcx
    addq %rdx, %rcx
    movq %rcx, %rdx
    addq %rcx, %rdx
    movq %rdx, %rcx
    addq %rdx, %rcx
    movq %rcx, %rcx
    addq %rcx, %rcx
    addq %rcx, %rdx
    movq %rdx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/fact


# patch_instructions

	.align 16
conclusion:


	.align 16
start:
    movq $1, %rdx
    addq %rdx, %rdx
    movq %rdx, %rcx
    addq %rdx, %rcx
    addq %rcx, %rdx
    movq %rdx, %rcx
    addq %rdx, %rcx
    movq %rcx, %rdx
    addq %rcx, %rdx
    movq %rdx, %rcx
    addq %rdx, %rcx
    addq %rcx, %rcx
    addq %rcx, %rdx
    movq %rdx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/fact


# prelude_and_conclusion

	.align 16
conclusion:
    popq %rbp
    retq 

	.align 16
start:
    movq $1, %rdx
    addq %rdx, %rdx
    movq %rdx, %rcx
    addq %rdx, %rcx
    addq %rcx, %rdx
    movq %rdx, %rcx
    addq %rdx, %rcx
    movq %rcx, %rdx
    addq %rcx, %rdx
    movq %rdx, %rcx
    addq %rdx, %rcx
    addq %rcx, %rcx
    addq %rcx, %rdx
    movq %rdx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.globl main
	.align 16
main:
    pushq %rbp
    movq %rsp, %rbp
    jmp start





# source program: fib

    a = 1
    b = 1
    c = (a + b)
    print(c)
    a = b
    b = c
    c = (a + b)
    print(c)
    a = b
    b = c
    c = (a + b)
    print(c)
    a = b
    b = c
    c = (a + b)
    print(c)
    a = b
    b = c
    c = (a + b)
    print(c)

Module([  Assign([Name('a')], Constant(1)),   Assign([Name('b')], Constant(1)),   Assign([Name('c')], BinOp(Name('a'), Add(), Name('b'))),   Expr(Call(Name('print'), [Name('c')])),   Assign([Name('a')], Name('b')),   Assign([Name('b')], Name('c')),   Assign([Name('c')], BinOp(Name('a'), Add(), Name('b'))),   Expr(Call(Name('print'), [Name('c')])),   Assign([Name('a')], Name('b')),   Assign([Name('b')], Name('c')),   Assign([Name('c')], BinOp(Name('a'), Add(), Name('b'))),   Expr(Call(Name('print'), [Name('c')])),   Assign([Name('a')], Name('b')),   Assign([Name('b')], Name('c')),   Assign([Name('c')], BinOp(Name('a'), Add(), Name('b'))),   Expr(Call(Name('print'), [Name('c')])),   Assign([Name('a')], Name('b')),   Assign([Name('b')], Name('c')),   Assign([Name('c')], BinOp(Name('a'), Add(), Name('b'))),   Expr(Call(Name('print'), [Name('c')]))])


# type checking source program


# partial_eval

    a = 1
    b = 1
    c = (a + b)
    print(c)
    a = b
    b = c
    c = (a + b)
    print(c)
    a = b
    b = c
    c = (a + b)
    print(c)
    a = b
    b = c
    c = (a + b)
    print(c)
    a = b
    b = c
    c = (a + b)
    print(c)

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/fib


# shrink

    a = 1
    b = 1
    c = (a + b)
    print(c)
    a = b
    b = c
    c = (a + b)
    print(c)
    a = b
    b = c
    c = (a + b)
    print(c)
    a = b
    b = c
    c = (a + b)
    print(c)
    a = b
    b = c
    c = (a + b)
    print(c)

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/fib


# remove_complex_operands

    a = 1
    b = 1
    c = (a + b)
    print(c)
    a = b
    b = c
    c = (a + b)
    print(c)
    a = b
    b = c
    c = (a + b)
    print(c)
    a = b
    b = c
    c = (a + b)
    print(c)
    a = b
    b = c
    c = (a + b)
    print(c)
Module([  Assign([Name('a')], Constant(1)),   Assign([Name('b')], Constant(1)),   Assign([Name('c')], BinOp(Name('a'), Add(), Name('b'))),   Expr(Call(Name('print'), [Name('c')])),   Assign([Name('a')], Name('b')),   Assign([Name('b')], Name('c')),   Assign([Name('c')], BinOp(Name('a'), Add(), Name('b'))),   Expr(Call(Name('print'), [Name('c')])),   Assign([Name('a')], Name('b')),   Assign([Name('b')], Name('c')),   Assign([Name('c')], BinOp(Name('a'), Add(), Name('b'))),   Expr(Call(Name('print'), [Name('c')])),   Assign([Name('a')], Name('b')),   Assign([Name('b')], Name('c')),   Assign([Name('c')], BinOp(Name('a'), Add(), Name('b'))),   Expr(Call(Name('print'), [Name('c')])),   Assign([Name('a')], Name('b')),   Assign([Name('b')], Name('c')),   Assign([Name('c')], BinOp(Name('a'), Add(), Name('b'))),   Expr(Call(Name('print'), [Name('c')]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/fib


# explicate_control

start:
    a = 1
    b = 1
    c = (a + b)
    print(c)
    a = b
    b = c
    c = (a + b)
    print(c)
    a = b
    b = c
    c = (a + b)
    print(c)
    a = b
    b = c
    c = (a + b)
    print(c)
    a = b
    b = c
    c = (a + b)
    print(c)
    return 0

CProgram(body={'start': [  Assign([Name('a')], Constant(1)),   Assign([Name('b')], Constant(1)),   Assign([Name('c')], BinOp(Name('a'), Add(), Name('b'))),   Expr(Call(Name('print'), [Name('c')])),   Assign([Name('a')], Name('b')),   Assign([Name('b')], Name('c')),   Assign([Name('c')], BinOp(Name('a'), Add(), Name('b'))),   Expr(Call(Name('print'), [Name('c')])),   Assign([Name('a')], Name('b')),   Assign([Name('b')], Name('c')),   Assign([Name('c')], BinOp(Name('a'), Add(), Name('b'))),   Expr(Call(Name('print'), [Name('c')])),   Assign([Name('a')], Name('b')),   Assign([Name('b')], Name('c')),   Assign([Name('c')], BinOp(Name('a'), Add(), Name('b'))),   Expr(Call(Name('print'), [Name('c')])),   Assign([Name('a')], Name('b')),   Assign([Name('b')], Name('c')),   Assign([Name('c')], BinOp(Name('a'), Add(), Name('b'))),   Expr(Call(Name('print'), [Name('c')])),   Return(Constant(0))]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/fib


# select_instructions

	.align 16
conclusion:


	.align 16
start:
    movq $1, a
    movq $1, b
    movq a, c
    addq b, c
    movq c, %rdi
    callq print_int
    movq b, a
    movq c, b
    movq a, c
    addq b, c
    movq c, %rdi
    callq print_int
    movq b, a
    movq c, b
    movq a, c
    addq b, c
    movq c, %rdi
    callq print_int
    movq b, a
    movq c, b
    movq a, c
    addq b, c
    movq c, %rdi
    callq print_int
    movq b, a
    movq c, b
    movq a, c
    addq b, c
    movq c, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/fib


# remove_jumps

	.align 16
conclusion:


	.align 16
start:
    movq $1, a
    movq $1, b
    movq a, c
    addq b, c
    movq c, %rdi
    callq print_int
    movq b, a
    movq c, b
    movq a, c
    addq b, c
    movq c, %rdi
    callq print_int
    movq b, a
    movq c, b
    movq a, c
    addq b, c
    movq c, %rdi
    callq print_int
    movq b, a
    movq c, b
    movq a, c
    addq b, c
    movq c, %rdi
    callq print_int
    movq b, a
    movq c, b
    movq a, c
    addq b, c
    movq c, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/fib


# assign_homes

	.align 16
conclusion:


	.align 16
start:
    movq $1, %rcx
    movq $1, %rbx
    movq %rcx, %r12
    addq %rbx, %r12
    movq %r12, %rdi
    callq print_int
    movq %rbx, %rcx
    movq %r12, %rbx
    movq %rcx, %r12
    addq %rbx, %r12
    movq %r12, %rdi
    callq print_int
    movq %rbx, %rcx
    movq %r12, %rbx
    movq %rcx, %r12
    addq %rbx, %r12
    movq %r12, %rdi
    callq print_int
    movq %rbx, %rcx
    movq %r12, %rbx
    movq %rcx, %r12
    addq %rbx, %r12
    movq %r12, %rdi
    callq print_int
    movq %rbx, %rcx
    movq %r12, %rbx
    movq %rcx, %r12
    addq %rbx, %r12
    movq %r12, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/fib


# patch_instructions

	.align 16
conclusion:


	.align 16
start:
    movq $1, %rcx
    movq $1, %rbx
    movq %rcx, %r12
    addq %rbx, %r12
    movq %r12, %rdi
    callq print_int
    movq %rbx, %rcx
    movq %r12, %rbx
    movq %rcx, %r12
    addq %rbx, %r12
    movq %r12, %rdi
    callq print_int
    movq %rbx, %rcx
    movq %r12, %rbx
    movq %rcx, %r12
    addq %rbx, %r12
    movq %r12, %rdi
    callq print_int
    movq %rbx, %rcx
    movq %r12, %rbx
    movq %rcx, %r12
    addq %rbx, %r12
    movq %r12, %rdi
    callq print_int
    movq %rbx, %rcx
    movq %r12, %rbx
    movq %rcx, %r12
    addq %rbx, %r12
    movq %r12, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/fib


# prelude_and_conclusion

	.align 16
conclusion:
    popq %r12
    popq %rbx
    popq %rbp
    retq 

	.align 16
start:
    movq $1, %rcx
    movq $1, %rbx
    movq %rcx, %r12
    addq %rbx, %r12
    movq %r12, %rdi
    callq print_int
    movq %rbx, %rcx
    movq %r12, %rbx
    movq %rcx, %r12
    addq %rbx, %r12
    movq %r12, %rdi
    callq print_int
    movq %rbx, %rcx
    movq %r12, %rbx
    movq %rcx, %r12
    addq %rbx, %r12
    movq %r12, %rdi
    callq print_int
    movq %rbx, %rcx
    movq %r12, %rbx
    movq %rcx, %r12
    addq %rbx, %r12
    movq %r12, %rdi
    callq print_int
    movq %rbx, %rcx
    movq %r12, %rbx
    movq %rcx, %r12
    addq %rbx, %r12
    movq %r12, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.globl main
	.align 16
main:
    pushq %rbp
    pushq %rbx
    pushq %r12
    movq %rsp, %rbp
    jmp start





# source program: mono_add

    a = 1
    a = (a + a)
    a = ((a + a) + a)
    print(a)

Module([  Assign([Name('a')], Constant(1)),   Assign([Name('a')], BinOp(Name('a'), Add(), Name('a'))),   Assign([Name('a')], BinOp(BinOp(Name('a'), Add(), Name('a')), Add(), Name('a'))),   Expr(Call(Name('print'), [Name('a')]))])


# type checking source program


# partial_eval

    a = 1
    a = (a + a)
    a = ((a + a) + a)
    print(a)

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/mono_add


# shrink

    a = 1
    a = (a + a)
    a = ((a + a) + a)
    print(a)

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/mono_add


# remove_complex_operands

    a = 1
    a = (a + a)
    tmp.26 = (a + a)
    a = (tmp.26 + a)
    print(a)
Module([  Assign([Name('a')], Constant(1)),   Assign([Name('a')], BinOp(Name('a'), Add(), Name('a'))),   Assign([Name('tmp.26')], BinOp(Name('a'), Add(), Name('a'))),   Assign([Name('a')], BinOp(Name('tmp.26'), Add(), Name('a'))),   Expr(Call(Name('print'), [Name('a')]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/mono_add


# explicate_control

start:
    a = 1
    a = (a + a)
    tmp.26 = (a + a)
    a = (tmp.26 + a)
    print(a)
    return 0

CProgram(body={'start': [  Assign([Name('a')], Constant(1)),   Assign([Name('a')], BinOp(Name('a'), Add(), Name('a'))),   Assign([Name('tmp.26')], BinOp(Name('a'), Add(), Name('a'))),   Assign([Name('a')], BinOp(Name('tmp.26'), Add(), Name('a'))),   Expr(Call(Name('print'), [Name('a')])),   Return(Constant(0))]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/mono_add


# select_instructions

	.align 16
conclusion:


	.align 16
start:
    movq $1, a
    addq a, a
    movq a, tmp.26
    addq a, tmp.26
    addq tmp.26, a
    movq a, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/mono_add


# remove_jumps

	.align 16
conclusion:


	.align 16
start:
    movq $1, a
    addq a, a
    movq a, tmp.26
    addq a, tmp.26
    addq tmp.26, a
    movq a, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/mono_add


# assign_homes

	.align 16
conclusion:


	.align 16
start:
    movq $1, %rdx
    addq %rdx, %rdx
    movq %rdx, %rcx
    addq %rdx, %rcx
    addq %rcx, %rdx
    movq %rdx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/mono_add


# patch_instructions

	.align 16
conclusion:


	.align 16
start:
    movq $1, %rdx
    addq %rdx, %rdx
    movq %rdx, %rcx
    addq %rdx, %rcx
    addq %rcx, %rdx
    movq %rdx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/mono_add


# prelude_and_conclusion

	.align 16
conclusion:
    popq %rbp
    retq 

	.align 16
start:
    movq $1, %rdx
    addq %rdx, %rdx
    movq %rdx, %rcx
    addq %rdx, %rcx
    addq %rcx, %rdx
    movq %rdx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.globl main
	.align 16
main:
    pushq %rbp
    movq %rsp, %rbp
    jmp start





# source program: side_effects_test

    a = input_int()
    (input_int() + 4)
    b = input_int()
    print((a + b))

Module([  Assign([Name('a')], Call(Name('input_int'), [])),   Expr(BinOp(Call(Name('input_int'), []), Add(), Constant(4))),   Assign([Name('b')], Call(Name('input_int'), [])),   Expr(Call(Name('print'), [BinOp(Name('a'), Add(), Name('b'))]))])


# type checking source program


# partial_eval

    a = input_int()
    (4 + input_int())
    b = input_int()
    print((a + b))

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/side_effects_test


# shrink

    a = input_int()
    (4 + input_int())
    b = input_int()
    print((a + b))

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/side_effects_test


# remove_complex_operands

    a = input_int()
    tmp.27 = input_int()
    (4 + tmp.27)
    b = input_int()
    tmp.28 = (a + b)
    print(tmp.28)
Module([  Assign([Name('a')], Call(Name('input_int'), [])),   Assign([Name('tmp.27')], Call(Name('input_int'), [])),   Expr(BinOp(Constant(4), Add(), Name('tmp.27'))),   Assign([Name('b')], Call(Name('input_int'), [])),   Assign([Name('tmp.28')], BinOp(Name('a'), Add(), Name('b'))),   Expr(Call(Name('print'), [Name('tmp.28')]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/side_effects_test


# explicate_control

start:
    a = input_int()
    tmp.27 = input_int()
    b = input_int()
    tmp.28 = (a + b)
    print(tmp.28)
    return 0

CProgram(body={'start': [  Assign([Name('a')], Call(Name('input_int'), [])),   Assign([Name('tmp.27')], Call(Name('input_int'), [])),   Assign([Name('b')], Call(Name('input_int'), [])),   Assign([Name('tmp.28')], BinOp(Name('a'), Add(), Name('b'))),   Expr(Call(Name('print'), [Name('tmp.28')])),   Return(Constant(0))]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/side_effects_test


# select_instructions

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, a
    callq read_int
    movq %rax, tmp.27
    callq read_int
    movq %rax, b
    movq a, tmp.28
    addq b, tmp.28
    movq tmp.28, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/side_effects_test


# remove_jumps

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, a
    callq read_int
    movq %rax, tmp.27
    callq read_int
    movq %rax, b
    movq a, tmp.28
    addq b, tmp.28
    movq tmp.28, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/side_effects_test


# assign_homes

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, %rbx
    callq read_int
    movq %rax, %rcx
    callq read_int
    movq %rax, %rcx
    movq %rbx, %rbx
    addq %rcx, %rbx
    movq %rbx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/side_effects_test


# patch_instructions

	.align 16
conclusion:


	.align 16
start:
    callq read_int
    movq %rax, %rbx
    callq read_int
    movq %rax, %rcx
    callq read_int
    movq %rax, %rcx
    addq %rcx, %rbx
    movq %rbx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/side_effects_test


# prelude_and_conclusion

	.align 16
conclusion:
    addq $8, %rsp
    popq %rbx
    popq %rbp
    retq 

	.align 16
start:
    callq read_int
    movq %rax, %rbx
    callq read_int
    movq %rax, %rcx
    callq read_int
    movq %rax, %rcx
    addq %rcx, %rbx
    movq %rbx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.globl main
	.align 16
main:
    pushq %rbp
    pushq %rbx
    movq %rsp, %rbp
    subq $8, %rsp
    jmp start





# source program: register_allocation_example

    v = 1
    w = 42
    x = (v + 7)
    y = x
    z = (x + w)
    print((z + -(y)))

Module([  Assign([Name('v')], Constant(1)),   Assign([Name('w')], Constant(42)),   Assign([Name('x')], BinOp(Name('v'), Add(), Constant(7))),   Assign([Name('y')], Name('x')),   Assign([Name('z')], BinOp(Name('x'), Add(), Name('w'))),   Expr(Call(Name('print'), [BinOp(Name('z'), Add(), UnaryOp(USub(), Name('y')))]))])


# type checking source program


# partial_eval

    v = 1
    w = 42
    x = (7 + v)
    y = x
    z = (x + w)
    print((z + -(y)))

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/register_allocation_example


# shrink

    v = 1
    w = 42
    x = (7 + v)
    y = x
    z = (x + w)
    print((z + -(y)))

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/register_allocation_example


# remove_complex_operands

    v = 1
    w = 42
    x = (7 + v)
    y = x
    z = (x + w)
    tmp.29 = -(y)
    tmp.30 = (z + tmp.29)
    print(tmp.30)
Module([  Assign([Name('v')], Constant(1)),   Assign([Name('w')], Constant(42)),   Assign([Name('x')], BinOp(Constant(7), Add(), Name('v'))),   Assign([Name('y')], Name('x')),   Assign([Name('z')], BinOp(Name('x'), Add(), Name('w'))),   Assign([Name('tmp.29')], UnaryOp(USub(), Name('y'))),   Assign([Name('tmp.30')], BinOp(Name('z'), Add(), Name('tmp.29'))),   Expr(Call(Name('print'), [Name('tmp.30')]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/register_allocation_example


# explicate_control

start:
    v = 1
    w = 42
    x = (7 + v)
    y = x
    z = (x + w)
    tmp.29 = -(y)
    tmp.30 = (z + tmp.29)
    print(tmp.30)
    return 0

CProgram(body={'start': [  Assign([Name('v')], Constant(1)),   Assign([Name('w')], Constant(42)),   Assign([Name('x')], BinOp(Constant(7), Add(), Name('v'))),   Assign([Name('y')], Name('x')),   Assign([Name('z')], BinOp(Name('x'), Add(), Name('w'))),   Assign([Name('tmp.29')], UnaryOp(USub(), Name('y'))),   Assign([Name('tmp.30')], BinOp(Name('z'), Add(), Name('tmp.29'))),   Expr(Call(Name('print'), [Name('tmp.30')])),   Return(Constant(0))]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/register_allocation_example


# select_instructions

	.align 16
conclusion:


	.align 16
start:
    movq $1, v
    movq $42, w
    movq $7, x
    addq v, x
    movq x, y
    movq x, z
    addq w, z
    movq y, tmp.29
    negq tmp.29
    movq z, tmp.30
    addq tmp.29, tmp.30
    movq tmp.30, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/register_allocation_example


# remove_jumps

	.align 16
conclusion:


	.align 16
start:
    movq $1, v
    movq $42, w
    movq $7, x
    addq v, x
    movq x, y
    movq x, z
    addq w, z
    movq y, tmp.29
    negq tmp.29
    movq z, tmp.30
    addq tmp.29, tmp.30
    movq tmp.30, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/register_allocation_example


# assign_homes

	.align 16
conclusion:


	.align 16
start:
    movq $1, %rcx
    movq $42, %rdx
    movq $7, %rsi
    addq %rcx, %rsi
    movq %rsi, %rsi
    movq %rsi, %rcx
    addq %rdx, %rcx
    movq %rsi, %rsi
    negq %rsi
    movq %rcx, %rcx
    addq %rsi, %rcx
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/register_allocation_example


# patch_instructions

	.align 16
conclusion:


	.align 16
start:
    movq $1, %rcx
    movq $42, %rdx
    movq $7, %rsi
    addq %rcx, %rsi
    movq %rsi, %rcx
    addq %rdx, %rcx
    negq %rsi
    addq %rsi, %rcx
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/register_allocation_example


# prelude_and_conclusion

	.align 16
conclusion:
    popq %rbp
    retq 

	.align 16
start:
    movq $1, %rcx
    movq $42, %rdx
    movq $7, %rsi
    addq %rcx, %rsi
    movq %rsi, %rcx
    addq %rdx, %rcx
    negq %rsi
    addq %rsi, %rcx
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.globl main
	.align 16
main:
    pushq %rbp
    movq %rsp, %rbp
    jmp start





# source program: many_interference_vars

    a = 1
    b = 2
    c = 3
    d = 4
    e = 5
    f = 6
    g = 7
    h = 8
    i = 9
    j = 10
    k = 11
    l = 12
    m = 13
    n = 14
    o = 15
    p = 16
    print(a)
    print(b)
    print(c)
    print(d)
    print(e)
    print(f)
    print(g)
    print(h)
    print(i)
    print(j)
    print(k)
    print(l)
    print(m)
    print(n)
    print(o)
    print(p)

Module([  Assign([Name('a')], Constant(1)),   Assign([Name('b')], Constant(2)),   Assign([Name('c')], Constant(3)),   Assign([Name('d')], Constant(4)),   Assign([Name('e')], Constant(5)),   Assign([Name('f')], Constant(6)),   Assign([Name('g')], Constant(7)),   Assign([Name('h')], Constant(8)),   Assign([Name('i')], Constant(9)),   Assign([Name('j')], Constant(10)),   Assign([Name('k')], Constant(11)),   Assign([Name('l')], Constant(12)),   Assign([Name('m')], Constant(13)),   Assign([Name('n')], Constant(14)),   Assign([Name('o')], Constant(15)),   Assign([Name('p')], Constant(16)),   Expr(Call(Name('print'), [Name('a')])),   Expr(Call(Name('print'), [Name('b')])),   Expr(Call(Name('print'), [Name('c')])),   Expr(Call(Name('print'), [Name('d')])),   Expr(Call(Name('print'), [Name('e')])),   Expr(Call(Name('print'), [Name('f')])),   Expr(Call(Name('print'), [Name('g')])),   Expr(Call(Name('print'), [Name('h')])),   Expr(Call(Name('print'), [Name('i')])),   Expr(Call(Name('print'), [Name('j')])),   Expr(Call(Name('print'), [Name('k')])),   Expr(Call(Name('print'), [Name('l')])),   Expr(Call(Name('print'), [Name('m')])),   Expr(Call(Name('print'), [Name('n')])),   Expr(Call(Name('print'), [Name('o')])),   Expr(Call(Name('print'), [Name('p')]))])


# type checking source program


# partial_eval

    a = 1
    b = 2
    c = 3
    d = 4
    e = 5
    f = 6
    g = 7
    h = 8
    i = 9
    j = 10
    k = 11
    l = 12
    m = 13
    n = 14
    o = 15
    p = 16
    print(a)
    print(b)
    print(c)
    print(d)
    print(e)
    print(f)
    print(g)
    print(h)
    print(i)
    print(j)
    print(k)
    print(l)
    print(m)
    print(n)
    print(o)
    print(p)

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/many_interference_vars


# shrink

    a = 1
    b = 2
    c = 3
    d = 4
    e = 5
    f = 6
    g = 7
    h = 8
    i = 9
    j = 10
    k = 11
    l = 12
    m = 13
    n = 14
    o = 15
    p = 16
    print(a)
    print(b)
    print(c)
    print(d)
    print(e)
    print(f)
    print(g)
    print(h)
    print(i)
    print(j)
    print(k)
    print(l)
    print(m)
    print(n)
    print(o)
    print(p)

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/many_interference_vars


# remove_complex_operands

    a = 1
    b = 2
    c = 3
    d = 4
    e = 5
    f = 6
    g = 7
    h = 8
    i = 9
    j = 10
    k = 11
    l = 12
    m = 13
    n = 14
    o = 15
    p = 16
    print(a)
    print(b)
    print(c)
    print(d)
    print(e)
    print(f)
    print(g)
    print(h)
    print(i)
    print(j)
    print(k)
    print(l)
    print(m)
    print(n)
    print(o)
    print(p)
Module([  Assign([Name('a')], Constant(1)),   Assign([Name('b')], Constant(2)),   Assign([Name('c')], Constant(3)),   Assign([Name('d')], Constant(4)),   Assign([Name('e')], Constant(5)),   Assign([Name('f')], Constant(6)),   Assign([Name('g')], Constant(7)),   Assign([Name('h')], Constant(8)),   Assign([Name('i')], Constant(9)),   Assign([Name('j')], Constant(10)),   Assign([Name('k')], Constant(11)),   Assign([Name('l')], Constant(12)),   Assign([Name('m')], Constant(13)),   Assign([Name('n')], Constant(14)),   Assign([Name('o')], Constant(15)),   Assign([Name('p')], Constant(16)),   Expr(Call(Name('print'), [Name('a')])),   Expr(Call(Name('print'), [Name('b')])),   Expr(Call(Name('print'), [Name('c')])),   Expr(Call(Name('print'), [Name('d')])),   Expr(Call(Name('print'), [Name('e')])),   Expr(Call(Name('print'), [Name('f')])),   Expr(Call(Name('print'), [Name('g')])),   Expr(Call(Name('print'), [Name('h')])),   Expr(Call(Name('print'), [Name('i')])),   Expr(Call(Name('print'), [Name('j')])),   Expr(Call(Name('print'), [Name('k')])),   Expr(Call(Name('print'), [Name('l')])),   Expr(Call(Name('print'), [Name('m')])),   Expr(Call(Name('print'), [Name('n')])),   Expr(Call(Name('print'), [Name('o')])),   Expr(Call(Name('print'), [Name('p')]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/many_interference_vars


# explicate_control

start:
    a = 1
    b = 2
    c = 3
    d = 4
    e = 5
    f = 6
    g = 7
    h = 8
    i = 9
    j = 10
    k = 11
    l = 12
    m = 13
    n = 14
    o = 15
    p = 16
    print(a)
    print(b)
    print(c)
    print(d)
    print(e)
    print(f)
    print(g)
    print(h)
    print(i)
    print(j)
    print(k)
    print(l)
    print(m)
    print(n)
    print(o)
    print(p)
    return 0

CProgram(body={'start': [  Assign([Name('a')], Constant(1)),   Assign([Name('b')], Constant(2)),   Assign([Name('c')], Constant(3)),   Assign([Name('d')], Constant(4)),   Assign([Name('e')], Constant(5)),   Assign([Name('f')], Constant(6)),   Assign([Name('g')], Constant(7)),   Assign([Name('h')], Constant(8)),   Assign([Name('i')], Constant(9)),   Assign([Name('j')], Constant(10)),   Assign([Name('k')], Constant(11)),   Assign([Name('l')], Constant(12)),   Assign([Name('m')], Constant(13)),   Assign([Name('n')], Constant(14)),   Assign([Name('o')], Constant(15)),   Assign([Name('p')], Constant(16)),   Expr(Call(Name('print'), [Name('a')])),   Expr(Call(Name('print'), [Name('b')])),   Expr(Call(Name('print'), [Name('c')])),   Expr(Call(Name('print'), [Name('d')])),   Expr(Call(Name('print'), [Name('e')])),   Expr(Call(Name('print'), [Name('f')])),   Expr(Call(Name('print'), [Name('g')])),   Expr(Call(Name('print'), [Name('h')])),   Expr(Call(Name('print'), [Name('i')])),   Expr(Call(Name('print'), [Name('j')])),   Expr(Call(Name('print'), [Name('k')])),   Expr(Call(Name('print'), [Name('l')])),   Expr(Call(Name('print'), [Name('m')])),   Expr(Call(Name('print'), [Name('n')])),   Expr(Call(Name('print'), [Name('o')])),   Expr(Call(Name('print'), [Name('p')])),   Return(Constant(0))]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/many_interference_vars


# select_instructions

	.align 16
conclusion:


	.align 16
start:
    movq $1, a
    movq $2, b
    movq $3, c
    movq $4, d
    movq $5, e
    movq $6, f
    movq $7, g
    movq $8, h
    movq $9, i
    movq $10, j
    movq $11, k
    movq $12, l
    movq $13, m
    movq $14, n
    movq $15, o
    movq $16, p
    movq a, %rdi
    callq print_int
    movq b, %rdi
    callq print_int
    movq c, %rdi
    callq print_int
    movq d, %rdi
    callq print_int
    movq e, %rdi
    callq print_int
    movq f, %rdi
    callq print_int
    movq g, %rdi
    callq print_int
    movq h, %rdi
    callq print_int
    movq i, %rdi
    callq print_int
    movq j, %rdi
    callq print_int
    movq k, %rdi
    callq print_int
    movq l, %rdi
    callq print_int
    movq m, %rdi
    callq print_int
    movq n, %rdi
    callq print_int
    movq o, %rdi
    callq print_int
    movq p, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/many_interference_vars


# remove_jumps

	.align 16
conclusion:


	.align 16
start:
    movq $1, a
    movq $2, b
    movq $3, c
    movq $4, d
    movq $5, e
    movq $6, f
    movq $7, g
    movq $8, h
    movq $9, i
    movq $10, j
    movq $11, k
    movq $12, l
    movq $13, m
    movq $14, n
    movq $15, o
    movq $16, p
    movq a, %rdi
    callq print_int
    movq b, %rdi
    callq print_int
    movq c, %rdi
    callq print_int
    movq d, %rdi
    callq print_int
    movq e, %rdi
    callq print_int
    movq f, %rdi
    callq print_int
    movq g, %rdi
    callq print_int
    movq h, %rdi
    callq print_int
    movq i, %rdi
    callq print_int
    movq j, %rdi
    callq print_int
    movq k, %rdi
    callq print_int
    movq l, %rdi
    callq print_int
    movq m, %rdi
    callq print_int
    movq n, %rdi
    callq print_int
    movq o, %rdi
    callq print_int
    movq p, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/many_interference_vars


# assign_homes

	.align 16
conclusion:


	.align 16
start:
    movq $1, %rcx
    movq $2, %r12
    movq $3, %r13
    movq $4, %r14
    movq $5, -8(%rbp)
    movq $6, -16(%rbp)
    movq $7, %rbx
    movq $8, -24(%rbp)
    movq $9, -32(%rbp)
    movq $10, -40(%rbp)
    movq $11, -48(%rbp)
    movq $12, -56(%rbp)
    movq $13, -64(%rbp)
    movq $14, -72(%rbp)
    movq $15, -80(%rbp)
    movq $16, -88(%rbp)
    movq %rcx, %rdi
    callq print_int
    movq %r12, %rdi
    callq print_int
    movq %r13, %rdi
    callq print_int
    movq %r14, %rdi
    callq print_int
    movq -8(%rbp), %rdi
    callq print_int
    movq -16(%rbp), %rdi
    callq print_int
    movq %rbx, %rdi
    callq print_int
    movq -24(%rbp), %rdi
    callq print_int
    movq -32(%rbp), %rdi
    callq print_int
    movq -40(%rbp), %rdi
    callq print_int
    movq -48(%rbp), %rdi
    callq print_int
    movq -56(%rbp), %rdi
    callq print_int
    movq -64(%rbp), %rdi
    callq print_int
    movq -72(%rbp), %rdi
    callq print_int
    movq -80(%rbp), %rdi
    callq print_int
    movq -88(%rbp), %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/many_interference_vars


# patch_instructions

	.align 16
conclusion:


	.align 16
start:
    movq $1, %rcx
    movq $2, %r12
    movq $3, %r13
    movq $4, %r14
    movq $5, -8(%rbp)
    movq $6, -16(%rbp)
    movq $7, %rbx
    movq $8, -24(%rbp)
    movq $9, -32(%rbp)
    movq $10, -40(%rbp)
    movq $11, -48(%rbp)
    movq $12, -56(%rbp)
    movq $13, -64(%rbp)
    movq $14, -72(%rbp)
    movq $15, -80(%rbp)
    movq $16, -88(%rbp)
    movq %rcx, %rdi
    callq print_int
    movq %r12, %rdi
    callq print_int
    movq %r13, %rdi
    callq print_int
    movq %r14, %rdi
    callq print_int
    movq -8(%rbp), %rdi
    callq print_int
    movq -16(%rbp), %rdi
    callq print_int
    movq %rbx, %rdi
    callq print_int
    movq -24(%rbp), %rdi
    callq print_int
    movq -32(%rbp), %rdi
    callq print_int
    movq -40(%rbp), %rdi
    callq print_int
    movq -48(%rbp), %rdi
    callq print_int
    movq -56(%rbp), %rdi
    callq print_int
    movq -64(%rbp), %rdi
    callq print_int
    movq -72(%rbp), %rdi
    callq print_int
    movq -80(%rbp), %rdi
    callq print_int
    movq -88(%rbp), %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/many_interference_vars


# prelude_and_conclusion

	.align 16
conclusion:
    addq $96, %rsp
    popq %r14
    popq %r13
    popq %r12
    popq %rbx
    popq %rbp
    retq 

	.align 16
start:
    movq $1, %rcx
    movq $2, %r12
    movq $3, %r13
    movq $4, %r14
    movq $5, -8(%rbp)
    movq $6, -16(%rbp)
    movq $7, %rbx
    movq $8, -24(%rbp)
    movq $9, -32(%rbp)
    movq $10, -40(%rbp)
    movq $11, -48(%rbp)
    movq $12, -56(%rbp)
    movq $13, -64(%rbp)
    movq $14, -72(%rbp)
    movq $15, -80(%rbp)
    movq $16, -88(%rbp)
    movq %rcx, %rdi
    callq print_int
    movq %r12, %rdi
    callq print_int
    movq %r13, %rdi
    callq print_int
    movq %r14, %rdi
    callq print_int
    movq -8(%rbp), %rdi
    callq print_int
    movq -16(%rbp), %rdi
    callq print_int
    movq %rbx, %rdi
    callq print_int
    movq -24(%rbp), %rdi
    callq print_int
    movq -32(%rbp), %rdi
    callq print_int
    movq -40(%rbp), %rdi
    callq print_int
    movq -48(%rbp), %rdi
    callq print_int
    movq -56(%rbp), %rdi
    callq print_int
    movq -64(%rbp), %rdi
    callq print_int
    movq -72(%rbp), %rdi
    callq print_int
    movq -80(%rbp), %rdi
    callq print_int
    movq -88(%rbp), %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.globl main
	.align 16
main:
    pushq %rbp
    pushq %rbx
    pushq %r12
    pushq %r13
    pushq %r14
    movq %rsp, %rbp
    subq $96, %rsp
    jmp start





# source program: simple_condition

    a = 2
    b = input_int()
    if a == b:
      print(a)
    else:
      print(b)

Module([  Assign([Name('a')], Constant(2)),   Assign([Name('b')], Call(Name('input_int'), [])), If(Compare(Name('a'), [Eq()], [Name('b')]), [  Expr(Call(Name('print'), [Name('a')]))], [  Expr(Call(Name('print'), [Name('b')]))])])


# type checking source program


# partial_eval

    a = 2
    b = input_int()
    if a == b:
      print(a)
    else:
      print(b)

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/simple_condition


# shrink

    a = 2
    b = input_int()
    if a == b:
      print(a)
    else:
      print(b)

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/simple_condition


# remove_complex_operands

    a = 2
    b = input_int()
    if a == b:
      print(a)
    else:
      print(b)
Module([  Assign([Name('a')], Constant(2)),   Assign([Name('b')], Call(Name('input_int'), [])), If(Compare(Name('a'), [Eq()], [Name('b')]), [  Expr(Call(Name('print'), [Name('a')]))], [  Expr(Call(Name('print'), [Name('b')]))])])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/simple_condition


# explicate_control

block.31:
    return 0
block.32:
    print(a)
    goto block.31

block.33:
    print(b)
    goto block.31

start:
    a = 2
    b = input_int()
    if a == b:
      goto block.32

    else:
      goto block.33


CProgram(body={'block.31': [  Return(Constant(0))], 'block.32': [  Expr(Call(Name('print'), [Name('a')])), Goto(label='block.31')], 'block.33': [  Expr(Call(Name('print'), [Name('b')])), Goto(label='block.31')], 'start': [  Assign([Name('a')], Constant(2)),   Assign([Name('b')], Call(Name('input_int'), [])), If(Compare(Name('a'), [Eq()], [Name('b')]), [Goto(label='block.32')], [Goto(label='block.33')])]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/simple_condition


# select_instructions

	.align 16
conclusion:


	.align 16
block.31:
    movq $0, %rax
    jmp conclusion

	.align 16
block.32:
    movq a, %rdi
    callq print_int
    jmp block.31

	.align 16
block.33:
    movq b, %rdi
    callq print_int
    jmp block.31

	.align 16
start:
    movq $2, a
    callq read_int
    movq %rax, b
    cmpq b, a
    je block.32
    jmp block.33



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/simple_condition


# remove_jumps

	.align 16
conclusion:


	.align 16
block.31:
    movq $0, %rax
    jmp conclusion

	.align 16
block.32:
    movq a, %rdi
    callq print_int
    jmp block.31

	.align 16
start:
    movq $2, a
    callq read_int
    movq %rax, b
    cmpq b, a
    je block.32
    movq b, %rdi
    callq print_int
    jmp block.31



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/simple_condition


# assign_homes

	.align 16
conclusion:


	.align 16
block.31:
    movq $0, %rax
    jmp conclusion

	.align 16
block.32:
    movq %rbx, %rdi
    callq print_int
    jmp block.31

	.align 16
start:
    movq $2, %rbx
    callq read_int
    movq %rax, %rcx
    cmpq %rcx, %rbx
    je block.32
    movq %rcx, %rdi
    callq print_int
    jmp block.31



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/simple_condition


# patch_instructions

	.align 16
conclusion:


	.align 16
block.31:
    movq $0, %rax
    jmp conclusion

	.align 16
block.32:
    movq %rbx, %rdi
    callq print_int
    jmp block.31

	.align 16
start:
    movq $2, %rbx
    callq read_int
    movq %rax, %rcx
    cmpq %rcx, %rbx
    je block.32
    movq %rcx, %rdi
    callq print_int
    jmp block.31



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/simple_condition


# prelude_and_conclusion

	.align 16
conclusion:
    addq $8, %rsp
    popq %rbx
    popq %rbp
    retq 

	.align 16
block.31:
    movq $0, %rax
    jmp conclusion

	.align 16
block.32:
    movq %rbx, %rdi
    callq print_int
    jmp block.31

	.align 16
start:
    movq $2, %rbx
    callq read_int
    movq %rax, %rcx
    cmpq %rcx, %rbx
    je block.32
    movq %rcx, %rdi
    callq print_int
    jmp block.31

	.globl main
	.align 16
main:
    pushq %rbp
    pushq %rbx
    movq %rsp, %rbp
    subq $8, %rsp
    jmp start





# source program: functional_if

    a = input_int()
    b = (a if a < 5 else input_int())
    print(b)

Module([  Assign([Name('a')], Call(Name('input_int'), [])),   Assign([Name('b')], IfExp(Compare(Name('a'), [LtE()], [Constant(5)]), Name('a'), Call(Name('input_int'), []))),   Expr(Call(Name('print'), [Name('b')]))])


# type checking source program


# partial_eval

    a = input_int()
    b = (a if a < 5 else input_int())
    print(b)

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/functional_if


# shrink

    a = input_int()
    b = (a if a < 5 else input_int())
    print(b)

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/functional_if


# remove_complex_operands

    a = input_int()
    b = ({

      produce a
} if a < 5 else {

      produce input_int()
})
    print(b)
Module([  Assign([Name('a')], Call(Name('input_int'), [])),   Assign([Name('b')], IfExp(Compare(Name('a'), [LtE()], [Constant(5)]), Begin(body=[], result=Name('a')), Begin(body=[], result=Call(Name('input_int'), [])))),   Expr(Call(Name('print'), [Name('b')]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/functional_if


# explicate_control

block.34:
    print(b)
    return 0
block.35:
    b = a
    goto block.34

block.36:
    b = input_int()
    goto block.34

start:
    a = input_int()
    if a < 5:
      goto block.35

    else:
      goto block.36


CProgram(body={'block.34': [  Expr(Call(Name('print'), [Name('b')])),   Return(Constant(0))], 'block.35': [  Assign([Name('b')], Name('a')), Goto(label='block.34')], 'block.36': [  Assign([Name('b')], Call(Name('input_int'), [])), Goto(label='block.34')], 'start': [  Assign([Name('a')], Call(Name('input_int'), [])), If(Compare(Name('a'), [LtE()], [Constant(5)]), [Goto(label='block.35')], [Goto(label='block.36')])]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/functional_if


# select_instructions

	.align 16
conclusion:


	.align 16
block.34:
    movq b, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.35:
    movq a, b
    jmp block.34

	.align 16
block.36:
    callq read_int
    movq %rax, b
    jmp block.34

	.align 16
start:
    callq read_int
    movq %rax, a
    cmpq $5, a
    jle block.35
    jmp block.36



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/functional_if


# remove_jumps

	.align 16
conclusion:


	.align 16
block.34:
    movq b, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.35:
    movq a, b
    jmp block.34

	.align 16
start:
    callq read_int
    movq %rax, a
    cmpq $5, a
    jle block.35
    callq read_int
    movq %rax, b
    jmp block.34



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/functional_if


# assign_homes

	.align 16
conclusion:


	.align 16
block.34:
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.35:
    movq %rcx, %rcx
    jmp block.34

	.align 16
start:
    callq read_int
    movq %rax, %rcx
    cmpq $5, %rcx
    jle block.35
    callq read_int
    movq %rax, %rcx
    jmp block.34



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/functional_if


# patch_instructions

	.align 16
conclusion:


	.align 16
block.34:
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.35:
    jmp block.34

	.align 16
start:
    callq read_int
    movq %rax, %rcx
    cmpq $5, %rcx
    jle block.35
    callq read_int
    movq %rax, %rcx
    jmp block.34



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/functional_if


# prelude_and_conclusion

	.align 16
conclusion:
    popq %rbp
    retq 

	.align 16
block.34:
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.35:
    jmp block.34

	.align 16
start:
    callq read_int
    movq %rax, %rcx
    cmpq $5, %rcx
    jle block.35
    callq read_int
    movq %rax, %rcx
    jmp block.34

	.globl main
	.align 16
main:
    pushq %rbp
    movq %rsp, %rbp
    jmp start





# source program: fib_cond

    count = input_int()
    a = 2
    b = 3
    c = b
    if count > 0:
      c = (a + b)      a = b      b = c      count = (count - 1)      if count > 0:
        c = (a + b)        a = b        b = c        count = (count - 1)        if count > 0:
          c = (a + b)          a = b          b = c          count = (count - 1)
        else:
          print(c)
      else:
        print(c)
    else:
      print(c)

Module([  Assign([Name('count')], Call(Name('input_int'), [])),   Assign([Name('a')], Constant(2)),   Assign([Name('b')], Constant(3)),   Assign([Name('c')], Name('b')), If(Compare(Name('count'), [Gt()], [Constant(0)]), [  Assign([Name('c')], BinOp(Name('a'), Add(), Name('b'))),   Assign([Name('a')], Name('b')),   Assign([Name('b')], Name('c')),   Assign([Name('count')], BinOp(Name('count'), Sub(), Constant(1))), If(Compare(Name('count'), [Gt()], [Constant(0)]), [  Assign([Name('c')], BinOp(Name('a'), Add(), Name('b'))),   Assign([Name('a')], Name('b')),   Assign([Name('b')], Name('c')),   Assign([Name('count')], BinOp(Name('count'), Sub(), Constant(1))), If(Compare(Name('count'), [Gt()], [Constant(0)]), [  Assign([Name('c')], BinOp(Name('a'), Add(), Name('b'))),   Assign([Name('a')], Name('b')),   Assign([Name('b')], Name('c')),   Assign([Name('count')], BinOp(Name('count'), Sub(), Constant(1)))], [  Expr(Call(Name('print'), [Name('c')]))])], [  Expr(Call(Name('print'), [Name('c')]))])], [  Expr(Call(Name('print'), [Name('c')]))])])


# type checking source program


# partial_eval

    count = input_int()
    a = 2
    b = 3
    c = b
    if count > 0:
      c = (a + b)      a = b      b = c      count = (count - 1)      if count > 0:
        c = (a + b)        a = b        b = c        count = (count - 1)        if count > 0:
          c = (a + b)          a = b          b = c          count = (count - 1)
        else:
          print(c)
      else:
        print(c)
    else:
      print(c)

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/fib_cond


# shrink

    count = input_int()
    a = 2
    b = 3
    c = b
    if count > 0:
      c = (a + b)      a = b      b = c      count = (count - 1)      if count > 0:
        c = (a + b)        a = b        b = c        count = (count - 1)        if count > 0:
          c = (a + b)          a = b          b = c          count = (count - 1)
        else:
          print(c)
      else:
        print(c)
    else:
      print(c)

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/fib_cond


# remove_complex_operands

    count = input_int()
    a = 2
    b = 3
    c = b
    if count > 0:
      c = (a + b)      a = b      b = c      count = (count - 1)      if count > 0:
        c = (a + b)        a = b        b = c        count = (count - 1)        if count > 0:
          c = (a + b)          a = b          b = c          count = (count - 1)
        else:
          print(c)
      else:
        print(c)
    else:
      print(c)
Module([  Assign([Name('count')], Call(Name('input_int'), [])),   Assign([Name('a')], Constant(2)),   Assign([Name('b')], Constant(3)),   Assign([Name('c')], Name('b')), If(Compare(Name('count'), [Gt()], [Constant(0)]), [  Assign([Name('c')], BinOp(Name('a'), Add(), Name('b'))),   Assign([Name('a')], Name('b')),   Assign([Name('b')], Name('c')),   Assign([Name('count')], BinOp(Name('count'), Sub(), Constant(1))), If(Compare(Name('count'), [Gt()], [Constant(0)]), [  Assign([Name('c')], BinOp(Name('a'), Add(), Name('b'))),   Assign([Name('a')], Name('b')),   Assign([Name('b')], Name('c')),   Assign([Name('count')], BinOp(Name('count'), Sub(), Constant(1))), If(Compare(Name('count'), [Gt()], [Constant(0)]), [  Assign([Name('c')], BinOp(Name('a'), Add(), Name('b'))),   Assign([Name('a')], Name('b')),   Assign([Name('b')], Name('c')),   Assign([Name('count')], BinOp(Name('count'), Sub(), Constant(1)))], [  Expr(Call(Name('print'), [Name('c')]))])], [  Expr(Call(Name('print'), [Name('c')]))])], [  Expr(Call(Name('print'), [Name('c')]))])])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/fib_cond


# explicate_control

block.37:
    return 0
block.38:
    c = (a + b)
    a = b
    b = c
    count = (count - 1)
    goto block.37

block.39:
    print(c)
    goto block.37

block.40:
    c = (a + b)
    a = b
    b = c
    count = (count - 1)
    if count > 0:
      goto block.38

    else:
      goto block.39

block.41:
    print(c)
    goto block.37

block.42:
    c = (a + b)
    a = b
    b = c
    count = (count - 1)
    if count > 0:
      goto block.40

    else:
      goto block.41

block.43:
    print(c)
    goto block.37

start:
    count = input_int()
    a = 2
    b = 3
    c = b
    if count > 0:
      goto block.42

    else:
      goto block.43


CProgram(body={'block.37': [  Return(Constant(0))], 'block.38': [  Assign([Name('c')], BinOp(Name('a'), Add(), Name('b'))),   Assign([Name('a')], Name('b')),   Assign([Name('b')], Name('c')),   Assign([Name('count')], BinOp(Name('count'), Sub(), Constant(1))), Goto(label='block.37')], 'block.39': [  Expr(Call(Name('print'), [Name('c')])), Goto(label='block.37')], 'block.40': [  Assign([Name('c')], BinOp(Name('a'), Add(), Name('b'))),   Assign([Name('a')], Name('b')),   Assign([Name('b')], Name('c')),   Assign([Name('count')], BinOp(Name('count'), Sub(), Constant(1))), If(Compare(Name('count'), [Gt()], [Constant(0)]), [Goto(label='block.38')], [Goto(label='block.39')])], 'block.41': [  Expr(Call(Name('print'), [Name('c')])), Goto(label='block.37')], 'block.42': [  Assign([Name('c')], BinOp(Name('a'), Add(), Name('b'))),   Assign([Name('a')], Name('b')),   Assign([Name('b')], Name('c')),   Assign([Name('count')], BinOp(Name('count'), Sub(), Constant(1))), If(Compare(Name('count'), [Gt()], [Constant(0)]), [Goto(label='block.40')], [Goto(label='block.41')])], 'block.43': [  Expr(Call(Name('print'), [Name('c')])), Goto(label='block.37')], 'start': [  Assign([Name('count')], Call(Name('input_int'), [])),   Assign([Name('a')], Constant(2)),   Assign([Name('b')], Constant(3)),   Assign([Name('c')], Name('b')), If(Compare(Name('count'), [Gt()], [Constant(0)]), [Goto(label='block.42')], [Goto(label='block.43')])]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/fib_cond


# select_instructions

	.align 16
conclusion:


	.align 16
block.37:
    movq $0, %rax
    jmp conclusion

	.align 16
block.38:
    movq a, c
    addq b, c
    movq b, a
    movq c, b
    subq $1, count
    jmp block.37

	.align 16
block.39:
    movq c, %rdi
    callq print_int
    jmp block.37

	.align 16
block.40:
    movq a, c
    addq b, c
    movq b, a
    movq c, b
    subq $1, count
    cmpq $0, count
    jg block.38
    jmp block.39

	.align 16
block.41:
    movq c, %rdi
    callq print_int
    jmp block.37

	.align 16
block.42:
    movq a, c
    addq b, c
    movq b, a
    movq c, b
    subq $1, count
    cmpq $0, count
    jg block.40
    jmp block.41

	.align 16
block.43:
    movq c, %rdi
    callq print_int
    jmp block.37

	.align 16
start:
    callq read_int
    movq %rax, count
    movq $2, a
    movq $3, b
    movq b, c
    cmpq $0, count
    jg block.42
    jmp block.43



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/fib_cond


# remove_jumps

	.align 16
conclusion:


	.align 16
block.37:
    movq $0, %rax
    jmp conclusion

	.align 16
block.38:
    movq a, c
    addq b, c
    movq b, a
    movq c, b
    subq $1, count
    jmp block.37

	.align 16
block.40:
    movq a, c
    addq b, c
    movq b, a
    movq c, b
    subq $1, count
    cmpq $0, count
    jg block.38
    movq c, %rdi
    callq print_int
    jmp block.37

	.align 16
block.42:
    movq a, c
    addq b, c
    movq b, a
    movq c, b
    subq $1, count
    cmpq $0, count
    jg block.40
    movq c, %rdi
    callq print_int
    jmp block.37

	.align 16
start:
    callq read_int
    movq %rax, count
    movq $2, a
    movq $3, b
    movq b, c
    cmpq $0, count
    jg block.42
    movq c, %rdi
    callq print_int
    jmp block.37



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/fib_cond


# assign_homes

	.align 16
conclusion:


	.align 16
block.37:
    movq $0, %rax
    jmp conclusion

	.align 16
block.38:
    movq %rdi, %rdx
    addq %rcx, %rdx
    movq %rcx, %rdi
    movq %rdx, %rcx
    subq $1, %rsi
    jmp block.37

	.align 16
block.40:
    movq %rdi, %rdx
    addq %rcx, %rdx
    movq %rcx, %rdi
    movq %rdx, %rcx
    subq $1, %rsi
    cmpq $0, %rsi
    jg block.38
    movq %rdx, %rdi
    callq print_int
    jmp block.37

	.align 16
block.42:
    movq %rdi, %rdx
    addq %rcx, %rdx
    movq %rcx, %rdi
    movq %rdx, %rcx
    subq $1, %rsi
    cmpq $0, %rsi
    jg block.40
    movq %rdx, %rdi
    callq print_int
    jmp block.37

	.align 16
start:
    callq read_int
    movq %rax, %rsi
    movq $2, %rdi
    movq $3, %rcx
    movq %rcx, %rdx
    cmpq $0, %rsi
    jg block.42
    movq %rdx, %rdi
    callq print_int
    jmp block.37



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/fib_cond


# patch_instructions

	.align 16
conclusion:


	.align 16
block.37:
    movq $0, %rax
    jmp conclusion

	.align 16
block.38:
    movq %rdi, %rdx
    addq %rcx, %rdx
    movq %rcx, %rdi
    movq %rdx, %rcx
    subq $1, %rsi
    jmp block.37

	.align 16
block.40:
    movq %rdi, %rdx
    addq %rcx, %rdx
    movq %rcx, %rdi
    movq %rdx, %rcx
    subq $1, %rsi
    cmpq $0, %rsi
    jg block.38
    movq %rdx, %rdi
    callq print_int
    jmp block.37

	.align 16
block.42:
    movq %rdi, %rdx
    addq %rcx, %rdx
    movq %rcx, %rdi
    movq %rdx, %rcx
    subq $1, %rsi
    cmpq $0, %rsi
    jg block.40
    movq %rdx, %rdi
    callq print_int
    jmp block.37

	.align 16
start:
    callq read_int
    movq %rax, %rsi
    movq $2, %rdi
    movq $3, %rcx
    movq %rcx, %rdx
    cmpq $0, %rsi
    jg block.42
    movq %rdx, %rdi
    callq print_int
    jmp block.37



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/fib_cond


# prelude_and_conclusion

	.align 16
conclusion:
    popq %rbp
    retq 

	.align 16
block.37:
    movq $0, %rax
    jmp conclusion

	.align 16
block.38:
    movq %rdi, %rdx
    addq %rcx, %rdx
    movq %rcx, %rdi
    movq %rdx, %rcx
    subq $1, %rsi
    jmp block.37

	.align 16
block.40:
    movq %rdi, %rdx
    addq %rcx, %rdx
    movq %rcx, %rdi
    movq %rdx, %rcx
    subq $1, %rsi
    cmpq $0, %rsi
    jg block.38
    movq %rdx, %rdi
    callq print_int
    jmp block.37

	.align 16
block.42:
    movq %rdi, %rdx
    addq %rcx, %rdx
    movq %rcx, %rdi
    movq %rdx, %rcx
    subq $1, %rsi
    cmpq $0, %rsi
    jg block.40
    movq %rdx, %rdi
    callq print_int
    jmp block.37

	.align 16
start:
    callq read_int
    movq %rax, %rsi
    movq $2, %rdi
    movq $3, %rcx
    movq %rcx, %rdx
    cmpq $0, %rsi
    jg block.42
    movq %rdx, %rdi
    callq print_int
    jmp block.37

	.globl main
	.align 16
main:
    pushq %rbp
    movq %rsp, %rbp
    jmp start





# source program: calc

    a = input_int()
    b = input_int()
    sum = (a + b)
    diff = (a - b)
    if sum > diff:
      print(sum)
    else:
      print(diff)
    result = (sum if sum > diff else diff)
    print(result)

Module([  Assign([Name('a')], Call(Name('input_int'), [])),   Assign([Name('b')], Call(Name('input_int'), [])),   Assign([Name('sum')], BinOp(Name('a'), Add(), Name('b'))),   Assign([Name('diff')], BinOp(Name('a'), Sub(), Name('b'))), If(Compare(Name('sum'), [Gt()], [Name('diff')]), [  Expr(Call(Name('print'), [Name('sum')]))], [  Expr(Call(Name('print'), [Name('diff')]))]),   Assign([Name('result')], IfExp(Compare(Name('sum'), [Gt()], [Name('diff')]), Name('sum'), Name('diff'))),   Expr(Call(Name('print'), [Name('result')]))])


# type checking source program


# partial_eval

    a = input_int()
    b = input_int()
    sum = (a + b)
    diff = (a - b)
    if sum > diff:
      print(sum)
    else:
      print(diff)
    result = (sum if sum > diff else diff)
    print(result)

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/calc


# shrink

    a = input_int()
    b = input_int()
    sum = (a + b)
    diff = (a - b)
    if sum > diff:
      print(sum)
    else:
      print(diff)
    result = (sum if sum > diff else diff)
    print(result)

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/calc


# remove_complex_operands

    a = input_int()
    b = input_int()
    sum = (a + b)
    diff = (a - b)
    if sum > diff:
      print(sum)
    else:
      print(diff)
    result = ({

      produce sum
} if sum > diff else {

      produce diff
})
    print(result)
Module([  Assign([Name('a')], Call(Name('input_int'), [])),   Assign([Name('b')], Call(Name('input_int'), [])),   Assign([Name('sum')], BinOp(Name('a'), Add(), Name('b'))),   Assign([Name('diff')], BinOp(Name('a'), Sub(), Name('b'))), If(Compare(Name('sum'), [Gt()], [Name('diff')]), [  Expr(Call(Name('print'), [Name('sum')]))], [  Expr(Call(Name('print'), [Name('diff')]))]),   Assign([Name('result')], IfExp(Compare(Name('sum'), [Gt()], [Name('diff')]), Begin(body=[], result=Name('sum')), Begin(body=[], result=Name('diff')))),   Expr(Call(Name('print'), [Name('result')]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/calc


# explicate_control

block.44:
    print(result)
    return 0
block.45:
    result = sum
    goto block.44

block.46:
    result = diff
    goto block.44

block.47:
    if sum > diff:
      goto block.45

    else:
      goto block.46

block.48:
    print(sum)
    goto block.47

block.49:
    print(diff)
    goto block.47

start:
    a = input_int()
    b = input_int()
    sum = (a + b)
    diff = (a - b)
    if sum > diff:
      goto block.48

    else:
      goto block.49


CProgram(body={'block.44': [  Expr(Call(Name('print'), [Name('result')])),   Return(Constant(0))], 'block.45': [  Assign([Name('result')], Name('sum')), Goto(label='block.44')], 'block.46': [  Assign([Name('result')], Name('diff')), Goto(label='block.44')], 'block.47': [If(Compare(Name('sum'), [Gt()], [Name('diff')]), [Goto(label='block.45')], [Goto(label='block.46')])], 'block.48': [  Expr(Call(Name('print'), [Name('sum')])), Goto(label='block.47')], 'block.49': [  Expr(Call(Name('print'), [Name('diff')])), Goto(label='block.47')], 'start': [  Assign([Name('a')], Call(Name('input_int'), [])),   Assign([Name('b')], Call(Name('input_int'), [])),   Assign([Name('sum')], BinOp(Name('a'), Add(), Name('b'))),   Assign([Name('diff')], BinOp(Name('a'), Sub(), Name('b'))), If(Compare(Name('sum'), [Gt()], [Name('diff')]), [Goto(label='block.48')], [Goto(label='block.49')])]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/calc


# select_instructions

	.align 16
conclusion:


	.align 16
block.44:
    movq result, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.45:
    movq sum, result
    jmp block.44

	.align 16
block.46:
    movq diff, result
    jmp block.44

	.align 16
block.47:
    cmpq diff, sum
    jg block.45
    jmp block.46

	.align 16
block.48:
    movq sum, %rdi
    callq print_int
    jmp block.47

	.align 16
block.49:
    movq diff, %rdi
    callq print_int
    jmp block.47

	.align 16
start:
    callq read_int
    movq %rax, a
    callq read_int
    movq %rax, b
    movq a, sum
    addq b, sum
    movq a, diff
    subq b, diff
    cmpq diff, sum
    jg block.48
    jmp block.49



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/calc


# remove_jumps

	.align 16
conclusion:


	.align 16
block.44:
    movq result, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.45:
    movq sum, result
    jmp block.44

	.align 16
block.47:
    cmpq diff, sum
    jg block.45
    movq diff, result
    jmp block.44

	.align 16
block.48:
    movq sum, %rdi
    callq print_int
    jmp block.47

	.align 16
start:
    callq read_int
    movq %rax, a
    callq read_int
    movq %rax, b
    movq a, sum
    addq b, sum
    movq a, diff
    subq b, diff
    cmpq diff, sum
    jg block.48
    movq diff, %rdi
    callq print_int
    jmp block.47



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/calc


# assign_homes

	.align 16
conclusion:


	.align 16
block.44:
    movq %r12, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.45:
    movq %r12, %r12
    jmp block.44

	.align 16
block.47:
    cmpq %rbx, %r12
    jg block.45
    movq %rbx, %r12
    jmp block.44

	.align 16
block.48:
    movq %r12, %rdi
    callq print_int
    jmp block.47

	.align 16
start:
    callq read_int
    movq %rax, %rbx
    callq read_int
    movq %rax, %rcx
    movq %rbx, %r12
    addq %rcx, %r12
    movq %rbx, %rbx
    subq %rcx, %rbx
    cmpq %rbx, %r12
    jg block.48
    movq %rbx, %rdi
    callq print_int
    jmp block.47



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/calc


# patch_instructions

	.align 16
conclusion:


	.align 16
block.44:
    movq %r12, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.45:
    jmp block.44

	.align 16
block.47:
    cmpq %rbx, %r12
    jg block.45
    movq %rbx, %r12
    jmp block.44

	.align 16
block.48:
    movq %r12, %rdi
    callq print_int
    jmp block.47

	.align 16
start:
    callq read_int
    movq %rax, %rbx
    callq read_int
    movq %rax, %rcx
    movq %rbx, %r12
    addq %rcx, %r12
    subq %rcx, %rbx
    cmpq %rbx, %r12
    jg block.48
    movq %rbx, %rdi
    callq print_int
    jmp block.47



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/calc


# prelude_and_conclusion

	.align 16
conclusion:
    popq %r12
    popq %rbx
    popq %rbp
    retq 

	.align 16
block.44:
    movq %r12, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.45:
    jmp block.44

	.align 16
block.47:
    cmpq %rbx, %r12
    jg block.45
    movq %rbx, %r12
    jmp block.44

	.align 16
block.48:
    movq %r12, %rdi
    callq print_int
    jmp block.47

	.align 16
start:
    callq read_int
    movq %rax, %rbx
    callq read_int
    movq %rax, %rcx
    movq %rbx, %r12
    addq %rcx, %r12
    subq %rcx, %rbx
    cmpq %rbx, %r12
    jg block.48
    movq %rbx, %rdi
    callq print_int
    jmp block.47

	.globl main
	.align 16
main:
    pushq %rbp
    pushq %rbx
    pushq %r12
    movq %rsp, %rbp
    jmp start





# source program: max3

    a = input_int()
    b = input_int()
    c = input_int()
    max_value = (a if a > b else b)
    max_value = (max_value if max_value > c else c)
    print(max_value)

Module([  Assign([Name('a')], Call(Name('input_int'), [])),   Assign([Name('b')], Call(Name('input_int'), [])),   Assign([Name('c')], Call(Name('input_int'), [])),   Assign([Name('max_value')], IfExp(Compare(Name('a'), [Gt()], [Name('b')]), Name('a'), Name('b'))),   Assign([Name('max_value')], IfExp(Compare(Name('max_value'), [Gt()], [Name('c')]), Name('max_value'), Name('c'))),   Expr(Call(Name('print'), [Name('max_value')]))])


# type checking source program


# partial_eval

    a = input_int()
    b = input_int()
    c = input_int()
    max_value = (a if a > b else b)
    max_value = (max_value if max_value > c else c)
    print(max_value)

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/max3


# shrink

    a = input_int()
    b = input_int()
    c = input_int()
    max_value = (a if a > b else b)
    max_value = (max_value if max_value > c else c)
    print(max_value)

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/max3


# remove_complex_operands

    a = input_int()
    b = input_int()
    c = input_int()
    max_value = ({

      produce a
} if a > b else {

      produce b
})
    max_value = ({

      produce max_value
} if max_value > c else {

      produce c
})
    print(max_value)
Module([  Assign([Name('a')], Call(Name('input_int'), [])),   Assign([Name('b')], Call(Name('input_int'), [])),   Assign([Name('c')], Call(Name('input_int'), [])),   Assign([Name('max_value')], IfExp(Compare(Name('a'), [Gt()], [Name('b')]), Begin(body=[], result=Name('a')), Begin(body=[], result=Name('b')))),   Assign([Name('max_value')], IfExp(Compare(Name('max_value'), [Gt()], [Name('c')]), Begin(body=[], result=Name('max_value')), Begin(body=[], result=Name('c')))),   Expr(Call(Name('print'), [Name('max_value')]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/max3


# explicate_control

block.50:
    print(max_value)
    return 0
block.51:
    max_value = max_value
    goto block.50

block.52:
    max_value = c
    goto block.50

block.53:
    if max_value > c:
      goto block.51

    else:
      goto block.52

block.54:
    max_value = a
    goto block.53

block.55:
    max_value = b
    goto block.53

start:
    a = input_int()
    b = input_int()
    c = input_int()
    if a > b:
      goto block.54

    else:
      goto block.55


CProgram(body={'block.50': [  Expr(Call(Name('print'), [Name('max_value')])),   Return(Constant(0))], 'block.51': [  Assign([Name('max_value')], Name('max_value')), Goto(label='block.50')], 'block.52': [  Assign([Name('max_value')], Name('c')), Goto(label='block.50')], 'block.53': [If(Compare(Name('max_value'), [Gt()], [Name('c')]), [Goto(label='block.51')], [Goto(label='block.52')])], 'block.54': [  Assign([Name('max_value')], Name('a')), Goto(label='block.53')], 'block.55': [  Assign([Name('max_value')], Name('b')), Goto(label='block.53')], 'start': [  Assign([Name('a')], Call(Name('input_int'), [])),   Assign([Name('b')], Call(Name('input_int'), [])),   Assign([Name('c')], Call(Name('input_int'), [])), If(Compare(Name('a'), [Gt()], [Name('b')]), [Goto(label='block.54')], [Goto(label='block.55')])]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/max3


# select_instructions

	.align 16
conclusion:


	.align 16
block.50:
    movq max_value, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.51:
    movq max_value, max_value
    jmp block.50

	.align 16
block.52:
    movq c, max_value
    jmp block.50

	.align 16
block.53:
    cmpq c, max_value
    jg block.51
    jmp block.52

	.align 16
block.54:
    movq a, max_value
    jmp block.53

	.align 16
block.55:
    movq b, max_value
    jmp block.53

	.align 16
start:
    callq read_int
    movq %rax, a
    callq read_int
    movq %rax, b
    callq read_int
    movq %rax, c
    cmpq b, a
    jg block.54
    jmp block.55



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/max3


# remove_jumps

	.align 16
conclusion:


	.align 16
block.50:
    movq max_value, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.51:
    movq max_value, max_value
    jmp block.50

	.align 16
block.53:
    cmpq c, max_value
    jg block.51
    movq c, max_value
    jmp block.50

	.align 16
block.54:
    movq a, max_value
    jmp block.53

	.align 16
start:
    callq read_int
    movq %rax, a
    callq read_int
    movq %rax, b
    callq read_int
    movq %rax, c
    cmpq b, a
    jg block.54
    movq b, max_value
    jmp block.53



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/max3


# assign_homes

	.align 16
conclusion:


	.align 16
block.50:
    movq %r12, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.51:
    movq %r12, %r12
    jmp block.50

	.align 16
block.53:
    cmpq %rcx, %r12
    jg block.51
    movq %rcx, %r12
    jmp block.50

	.align 16
block.54:
    movq %r12, %r12
    jmp block.53

	.align 16
start:
    callq read_int
    movq %rax, %r12
    callq read_int
    movq %rax, %rbx
    callq read_int
    movq %rax, %rcx
    cmpq %rbx, %r12
    jg block.54
    movq %rbx, %r12
    jmp block.53



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/max3


# patch_instructions

	.align 16
conclusion:


	.align 16
block.50:
    movq %r12, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.51:
    jmp block.50

	.align 16
block.53:
    cmpq %rcx, %r12
    jg block.51
    movq %rcx, %r12
    jmp block.50

	.align 16
block.54:
    jmp block.53

	.align 16
start:
    callq read_int
    movq %rax, %r12
    callq read_int
    movq %rax, %rbx
    callq read_int
    movq %rax, %rcx
    cmpq %rbx, %r12
    jg block.54
    movq %rbx, %r12
    jmp block.53



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/max3


# prelude_and_conclusion

	.align 16
conclusion:
    popq %r12
    popq %rbx
    popq %rbp
    retq 

	.align 16
block.50:
    movq %r12, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.51:
    jmp block.50

	.align 16
block.53:
    cmpq %rcx, %r12
    jg block.51
    movq %rcx, %r12
    jmp block.50

	.align 16
block.54:
    jmp block.53

	.align 16
start:
    callq read_int
    movq %rax, %r12
    callq read_int
    movq %rax, %rbx
    callq read_int
    movq %rax, %rcx
    cmpq %rbx, %r12
    jg block.54
    movq %rbx, %r12
    jmp block.53

	.globl main
	.align 16
main:
    pushq %rbp
    pushq %rbx
    pushq %r12
    movq %rsp, %rbp
    jmp start





# source program: nod

    a = input_int()
    b = input_int()
    if a == b:
      print(a)
    else:
      if a > b:
        a = (a - b)
      else:
        b = (b - a)      if a == b:
        print(a)
      else:
        if a > b:
          a = (a - b)
        else:
          b = (b - a)        if a == b:
          print(a)
        else:
          if a > b:
            a = (a - b)
          else:
            b = (b - a)          print(a)

Module([  Assign([Name('a')], Call(Name('input_int'), [])),   Assign([Name('b')], Call(Name('input_int'), [])), If(Compare(Name('a'), [Eq()], [Name('b')]), [  Expr(Call(Name('print'), [Name('a')]))], [If(Compare(Name('a'), [Gt()], [Name('b')]), [  Assign([Name('a')], BinOp(Name('a'), Sub(), Name('b')))], [  Assign([Name('b')], BinOp(Name('b'), Sub(), Name('a')))]), If(Compare(Name('a'), [Eq()], [Name('b')]), [  Expr(Call(Name('print'), [Name('a')]))], [If(Compare(Name('a'), [Gt()], [Name('b')]), [  Assign([Name('a')], BinOp(Name('a'), Sub(), Name('b')))], [  Assign([Name('b')], BinOp(Name('b'), Sub(), Name('a')))]), If(Compare(Name('a'), [Eq()], [Name('b')]), [  Expr(Call(Name('print'), [Name('a')]))], [If(Compare(Name('a'), [Gt()], [Name('b')]), [  Assign([Name('a')], BinOp(Name('a'), Sub(), Name('b')))], [  Assign([Name('b')], BinOp(Name('b'), Sub(), Name('a')))]),   Expr(Call(Name('print'), [Name('a')]))])])])])


# type checking source program


# partial_eval

    a = input_int()
    b = input_int()
    if a == b:
      print(a)
    else:
      if a > b:
        a = (a - b)
      else:
        b = (b - a)      if a == b:
        print(a)
      else:
        if a > b:
          a = (a - b)
        else:
          b = (b - a)        if a == b:
          print(a)
        else:
          if a > b:
            a = (a - b)
          else:
            b = (b - a)          print(a)

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/nod


# shrink

    a = input_int()
    b = input_int()
    if a == b:
      print(a)
    else:
      if a > b:
        a = (a - b)
      else:
        b = (b - a)      if a == b:
        print(a)
      else:
        if a > b:
          a = (a - b)
        else:
          b = (b - a)        if a == b:
          print(a)
        else:
          if a > b:
            a = (a - b)
          else:
            b = (b - a)          print(a)

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/nod


# remove_complex_operands

    a = input_int()
    b = input_int()
    if a == b:
      print(a)
    else:
      if a > b:
        a = (a - b)
      else:
        b = (b - a)      if a == b:
        print(a)
      else:
        if a > b:
          a = (a - b)
        else:
          b = (b - a)        if a == b:
          print(a)
        else:
          if a > b:
            a = (a - b)
          else:
            b = (b - a)          print(a)
Module([  Assign([Name('a')], Call(Name('input_int'), [])),   Assign([Name('b')], Call(Name('input_int'), [])), If(Compare(Name('a'), [Eq()], [Name('b')]), [  Expr(Call(Name('print'), [Name('a')]))], [If(Compare(Name('a'), [Gt()], [Name('b')]), [  Assign([Name('a')], BinOp(Name('a'), Sub(), Name('b')))], [  Assign([Name('b')], BinOp(Name('b'), Sub(), Name('a')))]), If(Compare(Name('a'), [Eq()], [Name('b')]), [  Expr(Call(Name('print'), [Name('a')]))], [If(Compare(Name('a'), [Gt()], [Name('b')]), [  Assign([Name('a')], BinOp(Name('a'), Sub(), Name('b')))], [  Assign([Name('b')], BinOp(Name('b'), Sub(), Name('a')))]), If(Compare(Name('a'), [Eq()], [Name('b')]), [  Expr(Call(Name('print'), [Name('a')]))], [If(Compare(Name('a'), [Gt()], [Name('b')]), [  Assign([Name('a')], BinOp(Name('a'), Sub(), Name('b')))], [  Assign([Name('b')], BinOp(Name('b'), Sub(), Name('a')))]),   Expr(Call(Name('print'), [Name('a')]))])])])])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/nod


# explicate_control

block.56:
    return 0
block.57:
    print(a)
    goto block.56

block.58:
    print(a)
    goto block.56

block.59:
    print(a)
    goto block.56

block.60:
    print(a)
    goto block.56

block.61:
    a = (a - b)
    goto block.60

block.62:
    b = (b - a)
    goto block.60

block.63:
    if a > b:
      goto block.61

    else:
      goto block.62

block.64:
    if a == b:
      goto block.59

    else:
      goto block.63

block.65:
    a = (a - b)
    goto block.64

block.66:
    b = (b - a)
    goto block.64

block.67:
    if a > b:
      goto block.65

    else:
      goto block.66

block.68:
    if a == b:
      goto block.58

    else:
      goto block.67

block.69:
    a = (a - b)
    goto block.68

block.70:
    b = (b - a)
    goto block.68

block.71:
    if a > b:
      goto block.69

    else:
      goto block.70

start:
    a = input_int()
    b = input_int()
    if a == b:
      goto block.57

    else:
      goto block.71


CProgram(body={'block.56': [  Return(Constant(0))], 'block.57': [  Expr(Call(Name('print'), [Name('a')])), Goto(label='block.56')], 'block.58': [  Expr(Call(Name('print'), [Name('a')])), Goto(label='block.56')], 'block.59': [  Expr(Call(Name('print'), [Name('a')])), Goto(label='block.56')], 'block.60': [  Expr(Call(Name('print'), [Name('a')])), Goto(label='block.56')], 'block.61': [  Assign([Name('a')], BinOp(Name('a'), Sub(), Name('b'))), Goto(label='block.60')], 'block.62': [  Assign([Name('b')], BinOp(Name('b'), Sub(), Name('a'))), Goto(label='block.60')], 'block.63': [If(Compare(Name('a'), [Gt()], [Name('b')]), [Goto(label='block.61')], [Goto(label='block.62')])], 'block.64': [If(Compare(Name('a'), [Eq()], [Name('b')]), [Goto(label='block.59')], [Goto(label='block.63')])], 'block.65': [  Assign([Name('a')], BinOp(Name('a'), Sub(), Name('b'))), Goto(label='block.64')], 'block.66': [  Assign([Name('b')], BinOp(Name('b'), Sub(), Name('a'))), Goto(label='block.64')], 'block.67': [If(Compare(Name('a'), [Gt()], [Name('b')]), [Goto(label='block.65')], [Goto(label='block.66')])], 'block.68': [If(Compare(Name('a'), [Eq()], [Name('b')]), [Goto(label='block.58')], [Goto(label='block.67')])], 'block.69': [  Assign([Name('a')], BinOp(Name('a'), Sub(), Name('b'))), Goto(label='block.68')], 'block.70': [  Assign([Name('b')], BinOp(Name('b'), Sub(), Name('a'))), Goto(label='block.68')], 'block.71': [If(Compare(Name('a'), [Gt()], [Name('b')]), [Goto(label='block.69')], [Goto(label='block.70')])], 'start': [  Assign([Name('a')], Call(Name('input_int'), [])),   Assign([Name('b')], Call(Name('input_int'), [])), If(Compare(Name('a'), [Eq()], [Name('b')]), [Goto(label='block.57')], [Goto(label='block.71')])]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/nod


# select_instructions

	.align 16
conclusion:


	.align 16
block.56:
    movq $0, %rax
    jmp conclusion

	.align 16
block.57:
    movq a, %rdi
    callq print_int
    jmp block.56

	.align 16
block.58:
    movq a, %rdi
    callq print_int
    jmp block.56

	.align 16
block.59:
    movq a, %rdi
    callq print_int
    jmp block.56

	.align 16
block.60:
    movq a, %rdi
    callq print_int
    jmp block.56

	.align 16
block.61:
    subq b, a
    jmp block.60

	.align 16
block.62:
    subq a, b
    jmp block.60

	.align 16
block.63:
    cmpq b, a
    jg block.61
    jmp block.62

	.align 16
block.64:
    cmpq b, a
    je block.59
    jmp block.63

	.align 16
block.65:
    subq b, a
    jmp block.64

	.align 16
block.66:
    subq a, b
    jmp block.64

	.align 16
block.67:
    cmpq b, a
    jg block.65
    jmp block.66

	.align 16
block.68:
    cmpq b, a
    je block.58
    jmp block.67

	.align 16
block.69:
    subq b, a
    jmp block.68

	.align 16
block.70:
    subq a, b
    jmp block.68

	.align 16
block.71:
    cmpq b, a
    jg block.69
    jmp block.70

	.align 16
start:
    callq read_int
    movq %rax, a
    callq read_int
    movq %rax, b
    cmpq b, a
    je block.57
    jmp block.71



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/nod


# remove_jumps

	.align 16
conclusion:


	.align 16
block.56:
    movq $0, %rax
    jmp conclusion

	.align 16
block.59:
    movq a, %rdi
    callq print_int
    jmp block.56

	.align 16
block.60:
    movq a, %rdi
    callq print_int
    jmp block.56

	.align 16
block.61:
    subq b, a
    jmp block.60

	.align 16
block.64:
    cmpq b, a
    je block.59
    cmpq b, a
    jg block.61
    subq a, b
    jmp block.60

	.align 16
block.65:
    subq b, a
    jmp block.64

	.align 16
block.58:
    movq a, %rdi
    callq print_int
    jmp block.56

	.align 16
block.68:
    cmpq b, a
    je block.58
    cmpq b, a
    jg block.65
    subq a, b
    jmp block.64

	.align 16
block.69:
    subq b, a
    jmp block.68

	.align 16
block.57:
    movq a, %rdi
    callq print_int
    jmp block.56

	.align 16
start:
    callq read_int
    movq %rax, a
    callq read_int
    movq %rax, b
    cmpq b, a
    je block.57
    cmpq b, a
    jg block.69
    subq a, b
    jmp block.68



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/nod


# assign_homes

	.align 16
conclusion:


	.align 16
block.56:
    movq $0, %rax
    jmp conclusion

	.align 16
block.59:
    movq %rbx, %rdi
    callq print_int
    jmp block.56

	.align 16
block.60:
    movq %rbx, %rdi
    callq print_int
    jmp block.56

	.align 16
block.61:
    subq %rcx, %rbx
    jmp block.60

	.align 16
block.64:
    cmpq %rcx, %rbx
    je block.59
    cmpq %rcx, %rbx
    jg block.61
    subq %rbx, %rcx
    jmp block.60

	.align 16
block.65:
    subq %rcx, %rbx
    jmp block.64

	.align 16
block.58:
    movq %rbx, %rdi
    callq print_int
    jmp block.56

	.align 16
block.68:
    cmpq %rcx, %rbx
    je block.58
    cmpq %rcx, %rbx
    jg block.65
    subq %rbx, %rcx
    jmp block.64

	.align 16
block.69:
    subq %rcx, %rbx
    jmp block.68

	.align 16
block.57:
    movq %rbx, %rdi
    callq print_int
    jmp block.56

	.align 16
start:
    callq read_int
    movq %rax, %rbx
    callq read_int
    movq %rax, %rcx
    cmpq %rcx, %rbx
    je block.57
    cmpq %rcx, %rbx
    jg block.69
    subq %rbx, %rcx
    jmp block.68



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/nod


# patch_instructions

	.align 16
conclusion:


	.align 16
block.56:
    movq $0, %rax
    jmp conclusion

	.align 16
block.59:
    movq %rbx, %rdi
    callq print_int
    jmp block.56

	.align 16
block.60:
    movq %rbx, %rdi
    callq print_int
    jmp block.56

	.align 16
block.61:
    subq %rcx, %rbx
    jmp block.60

	.align 16
block.64:
    cmpq %rcx, %rbx
    je block.59
    cmpq %rcx, %rbx
    jg block.61
    subq %rbx, %rcx
    jmp block.60

	.align 16
block.65:
    subq %rcx, %rbx
    jmp block.64

	.align 16
block.58:
    movq %rbx, %rdi
    callq print_int
    jmp block.56

	.align 16
block.68:
    cmpq %rcx, %rbx
    je block.58
    cmpq %rcx, %rbx
    jg block.65
    subq %rbx, %rcx
    jmp block.64

	.align 16
block.69:
    subq %rcx, %rbx
    jmp block.68

	.align 16
block.57:
    movq %rbx, %rdi
    callq print_int
    jmp block.56

	.align 16
start:
    callq read_int
    movq %rax, %rbx
    callq read_int
    movq %rax, %rcx
    cmpq %rcx, %rbx
    je block.57
    cmpq %rcx, %rbx
    jg block.69
    subq %rbx, %rcx
    jmp block.68



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/nod


# prelude_and_conclusion

	.align 16
conclusion:
    addq $8, %rsp
    popq %rbx
    popq %rbp
    retq 

	.align 16
block.56:
    movq $0, %rax
    jmp conclusion

	.align 16
block.59:
    movq %rbx, %rdi
    callq print_int
    jmp block.56

	.align 16
block.60:
    movq %rbx, %rdi
    callq print_int
    jmp block.56

	.align 16
block.61:
    subq %rcx, %rbx
    jmp block.60

	.align 16
block.64:
    cmpq %rcx, %rbx
    je block.59
    cmpq %rcx, %rbx
    jg block.61
    subq %rbx, %rcx
    jmp block.60

	.align 16
block.65:
    subq %rcx, %rbx
    jmp block.64

	.align 16
block.58:
    movq %rbx, %rdi
    callq print_int
    jmp block.56

	.align 16
block.68:
    cmpq %rcx, %rbx
    je block.58
    cmpq %rcx, %rbx
    jg block.65
    subq %rbx, %rcx
    jmp block.64

	.align 16
block.69:
    subq %rcx, %rbx
    jmp block.68

	.align 16
block.57:
    movq %rbx, %rdi
    callq print_int
    jmp block.56

	.align 16
start:
    callq read_int
    movq %rax, %rbx
    callq read_int
    movq %rax, %rcx
    cmpq %rcx, %rbx
    je block.57
    cmpq %rcx, %rbx
    jg block.69
    subq %rbx, %rcx
    jmp block.68

	.globl main
	.align 16
main:
    pushq %rbp
    pushq %rbx
    movq %rsp, %rbp
    subq $8, %rsp
    jmp start





# source program: and_or

    a = True
    b = False
    c = False
    d = True
    e = False
    if ((c or d) or a):
      print(0)
    else:
      print(1)
    if (d and (a or input_int() == 4)):
      print(2)
    else:
      print(3)
    if (e and d):
      print(5)
    else:
      print(6)
    if (((input_int() + 1) == 5 and (input_int() - 4) == 0) and input_int() == 8):
      print(7)
    else:
      print(8)
    if (((input_int() + 1) == 5 or (input_int() - 4) == 0) or (input_int() == 8 or input_int() == 9)):
      print(9)
    else:
      print(10)
    if input_int() < input_int():
      if (a and b):
        print(11)
      else:
        print(12)
    else:
      print(13)

Module([  Assign([Name('a')], Constant(True)),   Assign([Name('b')], Constant(False)),   Assign([Name('c')], Constant(False)),   Assign([Name('d')], Constant(True)),   Assign([Name('e')], Constant(False)), If(Name('c') Or() Name('d') Or() Name('a'), [  Expr(Call(Name('print'), [Constant(0)]))], [  Expr(Call(Name('print'), [Constant(1)]))]), If(Name('d') And() Name('a') Or() Compare(Call(Name('input_int'), []), [Eq()], [Constant(4)]), [  Expr(Call(Name('print'), [Constant(2)]))], [  Expr(Call(Name('print'), [Constant(3)]))]), If(Name('e') And() Name('d'), [  Expr(Call(Name('print'), [Constant(5)]))], [  Expr(Call(Name('print'), [Constant(6)]))]), If(Compare(BinOp(Call(Name('input_int'), []), Add(), Constant(1)), [Eq()], [Constant(5)]) And() Compare(BinOp(Call(Name('input_int'), []), Sub(), Constant(4)), [Eq()], [Constant(0)]) And() Compare(Call(Name('input_int'), []), [Eq()], [Constant(8)]), [  Expr(Call(Name('print'), [Constant(7)]))], [  Expr(Call(Name('print'), [Constant(8)]))]), If(Compare(BinOp(Call(Name('input_int'), []), Add(), Constant(1)), [Eq()], [Constant(5)]) Or() Compare(BinOp(Call(Name('input_int'), []), Sub(), Constant(4)), [Eq()], [Constant(0)]) Or() Compare(Call(Name('input_int'), []), [Eq()], [Constant(8)]) Or() Compare(Call(Name('input_int'), []), [Eq()], [Constant(9)]), [  Expr(Call(Name('print'), [Constant(9)]))], [  Expr(Call(Name('print'), [Constant(10)]))]), If(Compare(Call(Name('input_int'), []), [Lt()], [Call(Name('input_int'), [])]), [If(Name('a') And() Name('b'), [  Expr(Call(Name('print'), [Constant(11)]))], [  Expr(Call(Name('print'), [Constant(12)]))])], [  Expr(Call(Name('print'), [Constant(13)]))])])


# type checking source program


# partial_eval

    a = True
    b = False
    c = False
    d = True
    e = False
    if ((c or d) or a):
      print(0)
    else:
      print(1)
    if (d and (a or input_int() == 4)):
      print(2)
    else:
      print(3)
    if (e and d):
      print(5)
    else:
      print(6)
    if ((input_int() == 4 and (input_int() - 4) == 0) and input_int() == 8):
      print(7)
    else:
      print(8)
    if ((input_int() == 4 or (input_int() - 4) == 0) or (input_int() == 8 or input_int() == 9)):
      print(9)
    else:
      print(10)
    if input_int() < input_int():
      if (a and b):
        print(11)
      else:
        print(12)
    else:
      print(13)

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/and_or


# shrink

    a = True
    b = False
    c = False
    d = True
    e = False
    if (True if (True if c else d) else a):
      print(0)
    else:
      print(1)
    if ((True if a else input_int() == 4) if d else False):
      print(2)
    else:
      print(3)
    if (d if e else False):
      print(5)
    else:
      print(6)
    if (input_int() == 8 if ((input_int() - 4) == 0 if input_int() == 4 else False) else False):
      print(7)
    else:
      print(8)
    if (True if (True if input_int() == 4 else (input_int() - 4) == 0) else (True if input_int() == 8 else input_int() == 9)):
      print(9)
    else:
      print(10)
    if input_int() < input_int():
      if (b if a else False):
        print(11)
      else:
        print(12)
    else:
      print(13)

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/and_or


# remove_complex_operands

    a = True
    b = False
    c = False
    d = True
    e = False
    if ({

      produce True
} if ({

      produce True
} if c else {

      produce d
}) else {

      produce a
}):
      print(0)
    else:
      print(1)
    if ({

      produce ({

        produce True
} if a else {
        tmp.72 = input_int()
        produce tmp.72 == 4
})
} if d else {

      produce False
}):
      print(2)
    else:
      print(3)
    if ({

      produce d
} if e else {

      produce False
}):
      print(5)
    else:
      print(6)
    tmp.73 = input_int()
    if ({
      tmp.76 = input_int()
      produce tmp.76 == 8
} if ({
      tmp.74 = input_int()
      tmp.75 = (tmp.74 - 4)
      produce tmp.75 == 0
} if tmp.73 == 4 else {

      produce False
}) else {

      produce False
}):
      print(7)
    else:
      print(8)
    tmp.77 = input_int()
    if ({

      produce True
} if ({

      produce True
} if tmp.77 == 4 else {
      tmp.78 = input_int()
      tmp.79 = (tmp.78 - 4)
      produce tmp.79 == 0
}) else {
      tmp.80 = input_int()
      produce ({

        produce True
} if tmp.80 == 8 else {
        tmp.81 = input_int()
        produce tmp.81 == 9
})
}):
      print(9)
    else:
      print(10)
    tmp.82 = input_int()
    tmp.83 = input_int()
    if tmp.82 < tmp.83:
      if ({

        produce b
} if a else {

        produce False
}):
        print(11)
      else:
        print(12)
    else:
      print(13)
Module([  Assign([Name('a')], Constant(True)),   Assign([Name('b')], Constant(False)),   Assign([Name('c')], Constant(False)),   Assign([Name('d')], Constant(True)),   Assign([Name('e')], Constant(False)), If(IfExp(IfExp(Name('c'), Begin(body=[], result=Constant(True)), Begin(body=[], result=Name('d'))), Begin(body=[], result=Constant(True)), Begin(body=[], result=Name('a'))), [  Expr(Call(Name('print'), [Constant(0)]))], [  Expr(Call(Name('print'), [Constant(1)]))]), If(IfExp(Name('d'), Begin(body=[], result=IfExp(Name('a'), Begin(body=[], result=Constant(True)), Begin(body=[  Assign([Name('tmp.72')], Call(Name('input_int'), []))], result=Compare(Name('tmp.72'), [Eq()], [Constant(4)])))), Begin(body=[], result=Constant(False))), [  Expr(Call(Name('print'), [Constant(2)]))], [  Expr(Call(Name('print'), [Constant(3)]))]), If(IfExp(Name('e'), Begin(body=[], result=Name('d')), Begin(body=[], result=Constant(False))), [  Expr(Call(Name('print'), [Constant(5)]))], [  Expr(Call(Name('print'), [Constant(6)]))]),   Assign([Name('tmp.73')], Call(Name('input_int'), [])), If(IfExp(IfExp(Compare(Name('tmp.73'), [Eq()], [Constant(4)]), Begin(body=[  Assign([Name('tmp.74')], Call(Name('input_int'), [])),   Assign([Name('tmp.75')], BinOp(Name('tmp.74'), Sub(), Constant(4)))], result=Compare(Name('tmp.75'), [Eq()], [Constant(0)])), Begin(body=[], result=Constant(False))), Begin(body=[  Assign([Name('tmp.76')], Call(Name('input_int'), []))], result=Compare(Name('tmp.76'), [Eq()], [Constant(8)])), Begin(body=[], result=Constant(False))), [  Expr(Call(Name('print'), [Constant(7)]))], [  Expr(Call(Name('print'), [Constant(8)]))]),   Assign([Name('tmp.77')], Call(Name('input_int'), [])), If(IfExp(IfExp(Compare(Name('tmp.77'), [Eq()], [Constant(4)]), Begin(body=[], result=Constant(True)), Begin(body=[  Assign([Name('tmp.78')], Call(Name('input_int'), [])),   Assign([Name('tmp.79')], BinOp(Name('tmp.78'), Sub(), Constant(4)))], result=Compare(Name('tmp.79'), [Eq()], [Constant(0)]))), Begin(body=[], result=Constant(True)), Begin(body=[  Assign([Name('tmp.80')], Call(Name('input_int'), []))], result=IfExp(Compare(Name('tmp.80'), [Eq()], [Constant(8)]), Begin(body=[], result=Constant(True)), Begin(body=[  Assign([Name('tmp.81')], Call(Name('input_int'), []))], result=Compare(Name('tmp.81'), [Eq()], [Constant(9)]))))), [  Expr(Call(Name('print'), [Constant(9)]))], [  Expr(Call(Name('print'), [Constant(10)]))]),   Assign([Name('tmp.82')], Call(Name('input_int'), [])),   Assign([Name('tmp.83')], Call(Name('input_int'), [])), If(Compare(Name('tmp.82'), [Lt()], [Name('tmp.83')]), [If(IfExp(Name('a'), Begin(body=[], result=Name('b')), Begin(body=[], result=Constant(False))), [  Expr(Call(Name('print'), [Constant(11)]))], [  Expr(Call(Name('print'), [Constant(12)]))])], [  Expr(Call(Name('print'), [Constant(13)]))])])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/and_or


# explicate_control

block.84:
    return 0
block.85:
    print(12)
    goto block.84

block.86:
    print(11)
    goto block.84

block.87:
    if b == False:
      goto block.85

    else:
      goto block.86

block.88:
    if a == False:
      goto block.85

    else:
      goto block.87

block.89:
    print(13)
    goto block.84

block.90:
    tmp.82 = input_int()
    tmp.83 = input_int()
    if tmp.82 < tmp.83:
      goto block.88

    else:
      goto block.89

block.91:
    print(9)
    goto block.90

block.92:
    print(10)
    goto block.90

block.93:
    tmp.81 = input_int()
    if tmp.81 == 9:
      goto block.91

    else:
      goto block.92

block.94:
    tmp.80 = input_int()
    if tmp.80 == 8:
      goto block.91

    else:
      goto block.93

block.95:
    tmp.78 = input_int()
    tmp.79 = (tmp.78 - 4)
    if tmp.79 == 0:
      goto block.91

    else:
      goto block.94

block.96:
    tmp.77 = input_int()
    if tmp.77 == 4:
      goto block.91

    else:
      goto block.95

block.97:
    print(7)
    goto block.96

block.98:
    print(8)
    goto block.96

block.99:
    tmp.76 = input_int()
    if tmp.76 == 8:
      goto block.97

    else:
      goto block.98

block.100:
    tmp.74 = input_int()
    tmp.75 = (tmp.74 - 4)
    if tmp.75 == 0:
      goto block.99

    else:
      goto block.98

block.101:
    tmp.73 = input_int()
    if tmp.73 == 4:
      goto block.100

    else:
      goto block.98

block.102:
    print(6)
    goto block.101

block.103:
    print(5)
    goto block.101

block.104:
    if d == False:
      goto block.102

    else:
      goto block.103

block.105:
    if e == False:
      goto block.102

    else:
      goto block.104

block.106:
    print(3)
    goto block.105

block.107:
    print(2)
    goto block.105

block.108:
    tmp.72 = input_int()
    if tmp.72 == 4:
      goto block.107

    else:
      goto block.106

block.109:
    if a == False:
      goto block.108

    else:
      goto block.107

block.110:
    if d == False:
      goto block.106

    else:
      goto block.109

block.111:
    print(1)
    goto block.110

block.112:
    print(0)
    goto block.110

block.113:
    if a == False:
      goto block.111

    else:
      goto block.112

block.114:
    if d == False:
      goto block.113

    else:
      goto block.112

start:
    a = True
    b = False
    c = False
    d = True
    e = False
    if c == False:
      goto block.114

    else:
      goto block.112


CProgram(body={'block.84': [  Return(Constant(0))], 'block.85': [  Expr(Call(Name('print'), [Constant(12)])), Goto(label='block.84')], 'block.86': [  Expr(Call(Name('print'), [Constant(11)])), Goto(label='block.84')], 'block.87': [If(Compare(Name('b'), [Eq()], [Constant(False)]), [Goto(label='block.85')], [Goto(label='block.86')])], 'block.88': [If(Compare(Name('a'), [Eq()], [Constant(False)]), [Goto(label='block.85')], [Goto(label='block.87')])], 'block.89': [  Expr(Call(Name('print'), [Constant(13)])), Goto(label='block.84')], 'block.90': [  Assign([Name('tmp.82')], Call(Name('input_int'), [])),   Assign([Name('tmp.83')], Call(Name('input_int'), [])), If(Compare(Name('tmp.82'), [Lt()], [Name('tmp.83')]), [Goto(label='block.88')], [Goto(label='block.89')])], 'block.91': [  Expr(Call(Name('print'), [Constant(9)])), Goto(label='block.90')], 'block.92': [  Expr(Call(Name('print'), [Constant(10)])), Goto(label='block.90')], 'block.93': [  Assign([Name('tmp.81')], Call(Name('input_int'), [])), If(Compare(Name('tmp.81'), [Eq()], [Constant(9)]), [Goto(label='block.91')], [Goto(label='block.92')])], 'block.94': [  Assign([Name('tmp.80')], Call(Name('input_int'), [])), If(Compare(Name('tmp.80'), [Eq()], [Constant(8)]), [Goto(label='block.91')], [Goto(label='block.93')])], 'block.95': [  Assign([Name('tmp.78')], Call(Name('input_int'), [])),   Assign([Name('tmp.79')], BinOp(Name('tmp.78'), Sub(), Constant(4))), If(Compare(Name('tmp.79'), [Eq()], [Constant(0)]), [Goto(label='block.91')], [Goto(label='block.94')])], 'block.96': [  Assign([Name('tmp.77')], Call(Name('input_int'), [])), If(Compare(Name('tmp.77'), [Eq()], [Constant(4)]), [Goto(label='block.91')], [Goto(label='block.95')])], 'block.97': [  Expr(Call(Name('print'), [Constant(7)])), Goto(label='block.96')], 'block.98': [  Expr(Call(Name('print'), [Constant(8)])), Goto(label='block.96')], 'block.99': [  Assign([Name('tmp.76')], Call(Name('input_int'), [])), If(Compare(Name('tmp.76'), [Eq()], [Constant(8)]), [Goto(label='block.97')], [Goto(label='block.98')])], 'block.100': [  Assign([Name('tmp.74')], Call(Name('input_int'), [])),   Assign([Name('tmp.75')], BinOp(Name('tmp.74'), Sub(), Constant(4))), If(Compare(Name('tmp.75'), [Eq()], [Constant(0)]), [Goto(label='block.99')], [Goto(label='block.98')])], 'block.101': [  Assign([Name('tmp.73')], Call(Name('input_int'), [])), If(Compare(Name('tmp.73'), [Eq()], [Constant(4)]), [Goto(label='block.100')], [Goto(label='block.98')])], 'block.102': [  Expr(Call(Name('print'), [Constant(6)])), Goto(label='block.101')], 'block.103': [  Expr(Call(Name('print'), [Constant(5)])), Goto(label='block.101')], 'block.104': [If(Compare(Name('d'), [Eq()], [Constant(False)]), [Goto(label='block.102')], [Goto(label='block.103')])], 'block.105': [If(Compare(Name('e'), [Eq()], [Constant(False)]), [Goto(label='block.102')], [Goto(label='block.104')])], 'block.106': [  Expr(Call(Name('print'), [Constant(3)])), Goto(label='block.105')], 'block.107': [  Expr(Call(Name('print'), [Constant(2)])), Goto(label='block.105')], 'block.108': [  Assign([Name('tmp.72')], Call(Name('input_int'), [])), If(Compare(Name('tmp.72'), [Eq()], [Constant(4)]), [Goto(label='block.107')], [Goto(label='block.106')])], 'block.109': [If(Compare(Name('a'), [Eq()], [Constant(False)]), [Goto(label='block.108')], [Goto(label='block.107')])], 'block.110': [If(Compare(Name('d'), [Eq()], [Constant(False)]), [Goto(label='block.106')], [Goto(label='block.109')])], 'block.111': [  Expr(Call(Name('print'), [Constant(1)])), Goto(label='block.110')], 'block.112': [  Expr(Call(Name('print'), [Constant(0)])), Goto(label='block.110')], 'block.113': [If(Compare(Name('a'), [Eq()], [Constant(False)]), [Goto(label='block.111')], [Goto(label='block.112')])], 'block.114': [If(Compare(Name('d'), [Eq()], [Constant(False)]), [Goto(label='block.113')], [Goto(label='block.112')])], 'start': [  Assign([Name('a')], Constant(True)),   Assign([Name('b')], Constant(False)),   Assign([Name('c')], Constant(False)),   Assign([Name('d')], Constant(True)),   Assign([Name('e')], Constant(False)), If(Compare(Name('c'), [Eq()], [Constant(False)]), [Goto(label='block.114')], [Goto(label='block.112')])]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/and_or


# select_instructions

	.align 16
conclusion:


	.align 16
block.84:
    movq $0, %rax
    jmp conclusion

	.align 16
block.85:
    movq $12, %rdi
    callq print_int
    jmp block.84

	.align 16
block.86:
    movq $11, %rdi
    callq print_int
    jmp block.84

	.align 16
block.87:
    cmpq $0, b
    je block.85
    jmp block.86

	.align 16
block.88:
    cmpq $0, a
    je block.85
    jmp block.87

	.align 16
block.89:
    movq $13, %rdi
    callq print_int
    jmp block.84

	.align 16
block.90:
    callq read_int
    movq %rax, tmp.82
    callq read_int
    movq %rax, tmp.83
    cmpq tmp.83, tmp.82
    jl block.88
    jmp block.89

	.align 16
block.91:
    movq $9, %rdi
    callq print_int
    jmp block.90

	.align 16
block.92:
    movq $10, %rdi
    callq print_int
    jmp block.90

	.align 16
block.93:
    callq read_int
    movq %rax, tmp.81
    cmpq $9, tmp.81
    je block.91
    jmp block.92

	.align 16
block.94:
    callq read_int
    movq %rax, tmp.80
    cmpq $8, tmp.80
    je block.91
    jmp block.93

	.align 16
block.95:
    callq read_int
    movq %rax, tmp.78
    movq tmp.78, tmp.79
    subq $4, tmp.79
    cmpq $0, tmp.79
    je block.91
    jmp block.94

	.align 16
block.96:
    callq read_int
    movq %rax, tmp.77
    cmpq $4, tmp.77
    je block.91
    jmp block.95

	.align 16
block.97:
    movq $7, %rdi
    callq print_int
    jmp block.96

	.align 16
block.98:
    movq $8, %rdi
    callq print_int
    jmp block.96

	.align 16
block.99:
    callq read_int
    movq %rax, tmp.76
    cmpq $8, tmp.76
    je block.97
    jmp block.98

	.align 16
block.100:
    callq read_int
    movq %rax, tmp.74
    movq tmp.74, tmp.75
    subq $4, tmp.75
    cmpq $0, tmp.75
    je block.99
    jmp block.98

	.align 16
block.101:
    callq read_int
    movq %rax, tmp.73
    cmpq $4, tmp.73
    je block.100
    jmp block.98

	.align 16
block.102:
    movq $6, %rdi
    callq print_int
    jmp block.101

	.align 16
block.103:
    movq $5, %rdi
    callq print_int
    jmp block.101

	.align 16
block.104:
    cmpq $0, d
    je block.102
    jmp block.103

	.align 16
block.105:
    cmpq $0, e
    je block.102
    jmp block.104

	.align 16
block.106:
    movq $3, %rdi
    callq print_int
    jmp block.105

	.align 16
block.107:
    movq $2, %rdi
    callq print_int
    jmp block.105

	.align 16
block.108:
    callq read_int
    movq %rax, tmp.72
    cmpq $4, tmp.72
    je block.107
    jmp block.106

	.align 16
block.109:
    cmpq $0, a
    je block.108
    jmp block.107

	.align 16
block.110:
    cmpq $0, d
    je block.106
    jmp block.109

	.align 16
block.111:
    movq $1, %rdi
    callq print_int
    jmp block.110

	.align 16
block.112:
    movq $0, %rdi
    callq print_int
    jmp block.110

	.align 16
block.113:
    cmpq $0, a
    je block.111
    jmp block.112

	.align 16
block.114:
    cmpq $0, d
    je block.113
    jmp block.112

	.align 16
start:
    movq $1, a
    movq $0, b
    movq $0, c
    movq $1, d
    movq $0, e
    cmpq $0, c
    je block.114
    jmp block.112



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/and_or


# remove_jumps

	.align 16
conclusion:


	.align 16
block.84:
    movq $0, %rax
    jmp conclusion

	.align 16
block.85:
    movq $12, %rdi
    callq print_int
    jmp block.84

	.align 16
block.88:
    cmpq $0, a
    je block.85
    cmpq $0, b
    je block.85
    movq $11, %rdi
    callq print_int
    jmp block.84

	.align 16
block.90:
    callq read_int
    movq %rax, tmp.82
    callq read_int
    movq %rax, tmp.83
    cmpq tmp.83, tmp.82
    jl block.88
    movq $13, %rdi
    callq print_int
    jmp block.84

	.align 16
block.91:
    movq $9, %rdi
    callq print_int
    jmp block.90

	.align 16
block.96:
    callq read_int
    movq %rax, tmp.77
    cmpq $4, tmp.77
    je block.91
    callq read_int
    movq %rax, tmp.78
    movq tmp.78, tmp.79
    subq $4, tmp.79
    cmpq $0, tmp.79
    je block.91
    callq read_int
    movq %rax, tmp.80
    cmpq $8, tmp.80
    je block.91
    callq read_int
    movq %rax, tmp.81
    cmpq $9, tmp.81
    je block.91
    movq $10, %rdi
    callq print_int
    jmp block.90

	.align 16
block.98:
    movq $8, %rdi
    callq print_int
    jmp block.96

	.align 16
block.97:
    movq $7, %rdi
    callq print_int
    jmp block.96

	.align 16
block.99:
    callq read_int
    movq %rax, tmp.76
    cmpq $8, tmp.76
    je block.97
    jmp block.98

	.align 16
block.100:
    callq read_int
    movq %rax, tmp.74
    movq tmp.74, tmp.75
    subq $4, tmp.75
    cmpq $0, tmp.75
    je block.99
    jmp block.98

	.align 16
block.101:
    callq read_int
    movq %rax, tmp.73
    cmpq $4, tmp.73
    je block.100
    jmp block.98

	.align 16
block.102:
    movq $6, %rdi
    callq print_int
    jmp block.101

	.align 16
block.105:
    cmpq $0, e
    je block.102
    cmpq $0, d
    je block.102
    movq $5, %rdi
    callq print_int
    jmp block.101

	.align 16
block.107:
    movq $2, %rdi
    callq print_int
    jmp block.105

	.align 16
block.106:
    movq $3, %rdi
    callq print_int
    jmp block.105

	.align 16
block.108:
    callq read_int
    movq %rax, tmp.72
    cmpq $4, tmp.72
    je block.107
    jmp block.106

	.align 16
block.110:
    cmpq $0, d
    je block.106
    cmpq $0, a
    je block.108
    jmp block.107

	.align 16
block.111:
    movq $1, %rdi
    callq print_int
    jmp block.110

	.align 16
block.112:
    movq $0, %rdi
    callq print_int
    jmp block.110

	.align 16
block.113:
    cmpq $0, a
    je block.111
    jmp block.112

	.align 16
block.114:
    cmpq $0, d
    je block.113
    jmp block.112

	.align 16
start:
    movq $1, a
    movq $0, b
    movq $0, c
    movq $1, d
    movq $0, e
    cmpq $0, c
    je block.114
    jmp block.112



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/and_or


# assign_homes

	.align 16
conclusion:


	.align 16
block.84:
    movq $0, %rax
    jmp conclusion

	.align 16
block.85:
    movq $12, %rdi
    callq print_int
    jmp block.84

	.align 16
block.88:
    cmpq $0, %r13
    je block.85
    cmpq $0, %r12
    je block.85
    movq $11, %rdi
    callq print_int
    jmp block.84

	.align 16
block.90:
    callq read_int
    movq %rax, %rbx
    callq read_int
    movq %rax, %rcx
    cmpq %rcx, %rbx
    jl block.88
    movq $13, %rdi
    callq print_int
    jmp block.84

	.align 16
block.91:
    movq $9, %rdi
    callq print_int
    jmp block.90

	.align 16
block.96:
    callq read_int
    movq %rax, %rcx
    cmpq $4, %rcx
    je block.91
    callq read_int
    movq %rax, %rcx
    movq %rcx, %rcx
    subq $4, %rcx
    cmpq $0, %rcx
    je block.91
    callq read_int
    movq %rax, %rcx
    cmpq $8, %rcx
    je block.91
    callq read_int
    movq %rax, %rcx
    cmpq $9, %rcx
    je block.91
    movq $10, %rdi
    callq print_int
    jmp block.90

	.align 16
block.98:
    movq $8, %rdi
    callq print_int
    jmp block.96

	.align 16
block.97:
    movq $7, %rdi
    callq print_int
    jmp block.96

	.align 16
block.99:
    callq read_int
    movq %rax, %rcx
    cmpq $8, %rcx
    je block.97
    jmp block.98

	.align 16
block.100:
    callq read_int
    movq %rax, %rcx
    movq %rcx, %rcx
    subq $4, %rcx
    cmpq $0, %rcx
    je block.99
    jmp block.98

	.align 16
block.101:
    callq read_int
    movq %rax, %rcx
    cmpq $4, %rcx
    je block.100
    jmp block.98

	.align 16
block.102:
    movq $6, %rdi
    callq print_int
    jmp block.101

	.align 16
block.105:
    cmpq $0, %r14
    je block.102
    cmpq $0, %rbx
    je block.102
    movq $5, %rdi
    callq print_int
    jmp block.101

	.align 16
block.107:
    movq $2, %rdi
    callq print_int
    jmp block.105

	.align 16
block.106:
    movq $3, %rdi
    callq print_int
    jmp block.105

	.align 16
block.108:
    callq read_int
    movq %rax, %rcx
    cmpq $4, %rcx
    je block.107
    jmp block.106

	.align 16
block.110:
    cmpq $0, %rbx
    je block.106
    cmpq $0, %r13
    je block.108
    jmp block.107

	.align 16
block.111:
    movq $1, %rdi
    callq print_int
    jmp block.110

	.align 16
block.112:
    movq $0, %rdi
    callq print_int
    jmp block.110

	.align 16
block.113:
    cmpq $0, %r13
    je block.111
    jmp block.112

	.align 16
block.114:
    cmpq $0, %rbx
    je block.113
    jmp block.112

	.align 16
start:
    movq $1, %r13
    movq $0, %r12
    movq $0, %rcx
    movq $1, %rbx
    movq $0, %r14
    cmpq $0, %rcx
    je block.114
    jmp block.112



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/and_or


# patch_instructions

	.align 16
conclusion:


	.align 16
block.84:
    movq $0, %rax
    jmp conclusion

	.align 16
block.85:
    movq $12, %rdi
    callq print_int
    jmp block.84

	.align 16
block.88:
    cmpq $0, %r13
    je block.85
    cmpq $0, %r12
    je block.85
    movq $11, %rdi
    callq print_int
    jmp block.84

	.align 16
block.90:
    callq read_int
    movq %rax, %rbx
    callq read_int
    movq %rax, %rcx
    cmpq %rcx, %rbx
    jl block.88
    movq $13, %rdi
    callq print_int
    jmp block.84

	.align 16
block.91:
    movq $9, %rdi
    callq print_int
    jmp block.90

	.align 16
block.96:
    callq read_int
    movq %rax, %rcx
    cmpq $4, %rcx
    je block.91
    callq read_int
    movq %rax, %rcx
    subq $4, %rcx
    cmpq $0, %rcx
    je block.91
    callq read_int
    movq %rax, %rcx
    cmpq $8, %rcx
    je block.91
    callq read_int
    movq %rax, %rcx
    cmpq $9, %rcx
    je block.91
    movq $10, %rdi
    callq print_int
    jmp block.90

	.align 16
block.98:
    movq $8, %rdi
    callq print_int
    jmp block.96

	.align 16
block.97:
    movq $7, %rdi
    callq print_int
    jmp block.96

	.align 16
block.99:
    callq read_int
    movq %rax, %rcx
    cmpq $8, %rcx
    je block.97
    jmp block.98

	.align 16
block.100:
    callq read_int
    movq %rax, %rcx
    subq $4, %rcx
    cmpq $0, %rcx
    je block.99
    jmp block.98

	.align 16
block.101:
    callq read_int
    movq %rax, %rcx
    cmpq $4, %rcx
    je block.100
    jmp block.98

	.align 16
block.102:
    movq $6, %rdi
    callq print_int
    jmp block.101

	.align 16
block.105:
    cmpq $0, %r14
    je block.102
    cmpq $0, %rbx
    je block.102
    movq $5, %rdi
    callq print_int
    jmp block.101

	.align 16
block.107:
    movq $2, %rdi
    callq print_int
    jmp block.105

	.align 16
block.106:
    movq $3, %rdi
    callq print_int
    jmp block.105

	.align 16
block.108:
    callq read_int
    movq %rax, %rcx
    cmpq $4, %rcx
    je block.107
    jmp block.106

	.align 16
block.110:
    cmpq $0, %rbx
    je block.106
    cmpq $0, %r13
    je block.108
    jmp block.107

	.align 16
block.111:
    movq $1, %rdi
    callq print_int
    jmp block.110

	.align 16
block.112:
    movq $0, %rdi
    callq print_int
    jmp block.110

	.align 16
block.113:
    cmpq $0, %r13
    je block.111
    jmp block.112

	.align 16
block.114:
    cmpq $0, %rbx
    je block.113
    jmp block.112

	.align 16
start:
    movq $1, %r13
    movq $0, %r12
    movq $0, %rcx
    movq $1, %rbx
    movq $0, %r14
    cmpq $0, %rcx
    je block.114
    jmp block.112



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/and_or


# prelude_and_conclusion

	.align 16
conclusion:
    popq %r14
    popq %r13
    popq %r12
    popq %rbx
    popq %rbp
    retq 

	.align 16
block.84:
    movq $0, %rax
    jmp conclusion

	.align 16
block.85:
    movq $12, %rdi
    callq print_int
    jmp block.84

	.align 16
block.88:
    cmpq $0, %r13
    je block.85
    cmpq $0, %r12
    je block.85
    movq $11, %rdi
    callq print_int
    jmp block.84

	.align 16
block.90:
    callq read_int
    movq %rax, %rbx
    callq read_int
    movq %rax, %rcx
    cmpq %rcx, %rbx
    jl block.88
    movq $13, %rdi
    callq print_int
    jmp block.84

	.align 16
block.91:
    movq $9, %rdi
    callq print_int
    jmp block.90

	.align 16
block.96:
    callq read_int
    movq %rax, %rcx
    cmpq $4, %rcx
    je block.91
    callq read_int
    movq %rax, %rcx
    subq $4, %rcx
    cmpq $0, %rcx
    je block.91
    callq read_int
    movq %rax, %rcx
    cmpq $8, %rcx
    je block.91
    callq read_int
    movq %rax, %rcx
    cmpq $9, %rcx
    je block.91
    movq $10, %rdi
    callq print_int
    jmp block.90

	.align 16
block.98:
    movq $8, %rdi
    callq print_int
    jmp block.96

	.align 16
block.97:
    movq $7, %rdi
    callq print_int
    jmp block.96

	.align 16
block.99:
    callq read_int
    movq %rax, %rcx
    cmpq $8, %rcx
    je block.97
    jmp block.98

	.align 16
block.100:
    callq read_int
    movq %rax, %rcx
    subq $4, %rcx
    cmpq $0, %rcx
    je block.99
    jmp block.98

	.align 16
block.101:
    callq read_int
    movq %rax, %rcx
    cmpq $4, %rcx
    je block.100
    jmp block.98

	.align 16
block.102:
    movq $6, %rdi
    callq print_int
    jmp block.101

	.align 16
block.105:
    cmpq $0, %r14
    je block.102
    cmpq $0, %rbx
    je block.102
    movq $5, %rdi
    callq print_int
    jmp block.101

	.align 16
block.107:
    movq $2, %rdi
    callq print_int
    jmp block.105

	.align 16
block.106:
    movq $3, %rdi
    callq print_int
    jmp block.105

	.align 16
block.108:
    callq read_int
    movq %rax, %rcx
    cmpq $4, %rcx
    je block.107
    jmp block.106

	.align 16
block.110:
    cmpq $0, %rbx
    je block.106
    cmpq $0, %r13
    je block.108
    jmp block.107

	.align 16
block.111:
    movq $1, %rdi
    callq print_int
    jmp block.110

	.align 16
block.112:
    movq $0, %rdi
    callq print_int
    jmp block.110

	.align 16
block.113:
    cmpq $0, %r13
    je block.111
    jmp block.112

	.align 16
block.114:
    cmpq $0, %rbx
    je block.113
    jmp block.112

	.align 16
start:
    movq $1, %r13
    movq $0, %r12
    movq $0, %rcx
    movq $1, %rbx
    movq $0, %r14
    cmpq $0, %rcx
    je block.114
    jmp block.112

	.globl main
	.align 16
main:
    pushq %rbp
    pushq %rbx
    pushq %r12
    pushq %r13
    pushq %r14
    movq %rsp, %rbp
    jmp start





# source program: complex_if_expr

    x = input_int()
    y = input_int()
    print(((y + 2) if (x == 0 if x < 1 else x == 2) else (y + 10)))

Module([  Assign([Name('x')], Call(Name('input_int'), [])),   Assign([Name('y')], Call(Name('input_int'), [])),   Expr(Call(Name('print'), [IfExp(IfExp(Compare(Name('x'), [Lt()], [Constant(1)]), Compare(Name('x'), [Eq()], [Constant(0)]), Compare(Name('x'), [Eq()], [Constant(2)])), BinOp(Name('y'), Add(), Constant(2)), BinOp(Name('y'), Add(), Constant(10)))]))])


# type checking source program


# partial_eval

    x = input_int()
    y = input_int()
    print(((2 + y) if (x == 0 if x < 1 else x == 2) else (10 + y)))

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/complex_if_expr


# shrink

    x = input_int()
    y = input_int()
    print(((2 + y) if (x == 0 if x < 1 else x == 2) else (10 + y)))

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/complex_if_expr


# remove_complex_operands

    x = input_int()
    y = input_int()
    tmp.115 = ({

      produce (2 + y)
} if ({

      produce x == 0
} if x < 1 else {

      produce x == 2
}) else {

      produce (10 + y)
})
    print(tmp.115)
Module([  Assign([Name('x')], Call(Name('input_int'), [])),   Assign([Name('y')], Call(Name('input_int'), [])),   Assign([Name('tmp.115')], IfExp(IfExp(Compare(Name('x'), [Lt()], [Constant(1)]), Begin(body=[], result=Compare(Name('x'), [Eq()], [Constant(0)])), Begin(body=[], result=Compare(Name('x'), [Eq()], [Constant(2)]))), Begin(body=[], result=BinOp(Constant(2), Add(), Name('y'))), Begin(body=[], result=BinOp(Constant(10), Add(), Name('y'))))),   Expr(Call(Name('print'), [Name('tmp.115')]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/complex_if_expr


# explicate_control

block.116:
    print(tmp.115)
    return 0
block.117:
    tmp.115 = (2 + y)
    goto block.116

block.118:
    tmp.115 = (10 + y)
    goto block.116

block.119:
    if x == 0:
      goto block.117

    else:
      goto block.118

block.120:
    if x == 2:
      goto block.117

    else:
      goto block.118

start:
    x = input_int()
    y = input_int()
    if x < 1:
      goto block.119

    else:
      goto block.120


CProgram(body={'block.116': [  Expr(Call(Name('print'), [Name('tmp.115')])),   Return(Constant(0))], 'block.117': [  Assign([Name('tmp.115')], BinOp(Constant(2), Add(), Name('y'))), Goto(label='block.116')], 'block.118': [  Assign([Name('tmp.115')], BinOp(Constant(10), Add(), Name('y'))), Goto(label='block.116')], 'block.119': [If(Compare(Name('x'), [Eq()], [Constant(0)]), [Goto(label='block.117')], [Goto(label='block.118')])], 'block.120': [If(Compare(Name('x'), [Eq()], [Constant(2)]), [Goto(label='block.117')], [Goto(label='block.118')])], 'start': [  Assign([Name('x')], Call(Name('input_int'), [])),   Assign([Name('y')], Call(Name('input_int'), [])), If(Compare(Name('x'), [Lt()], [Constant(1)]), [Goto(label='block.119')], [Goto(label='block.120')])]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/complex_if_expr


# select_instructions

	.align 16
conclusion:


	.align 16
block.116:
    movq tmp.115, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.117:
    movq $2, tmp.115
    addq y, tmp.115
    jmp block.116

	.align 16
block.118:
    movq $10, tmp.115
    addq y, tmp.115
    jmp block.116

	.align 16
block.119:
    cmpq $0, x
    je block.117
    jmp block.118

	.align 16
block.120:
    cmpq $2, x
    je block.117
    jmp block.118

	.align 16
start:
    callq read_int
    movq %rax, x
    callq read_int
    movq %rax, y
    cmpq $1, x
    jl block.119
    jmp block.120



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/complex_if_expr


# remove_jumps

	.align 16
conclusion:


	.align 16
block.116:
    movq tmp.115, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.117:
    movq $2, tmp.115
    addq y, tmp.115
    jmp block.116

	.align 16
block.118:
    movq $10, tmp.115
    addq y, tmp.115
    jmp block.116

	.align 16
block.119:
    cmpq $0, x
    je block.117
    jmp block.118

	.align 16
start:
    callq read_int
    movq %rax, x
    callq read_int
    movq %rax, y
    cmpq $1, x
    jl block.119
    cmpq $2, x
    je block.117
    jmp block.118



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/complex_if_expr


# assign_homes

	.align 16
conclusion:


	.align 16
block.116:
    movq %rdx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.117:
    movq $2, %rdx
    addq %rcx, %rdx
    jmp block.116

	.align 16
block.118:
    movq $10, %rdx
    addq %rcx, %rdx
    jmp block.116

	.align 16
block.119:
    cmpq $0, %rbx
    je block.117
    jmp block.118

	.align 16
start:
    callq read_int
    movq %rax, %rbx
    callq read_int
    movq %rax, %rcx
    cmpq $1, %rbx
    jl block.119
    cmpq $2, %rbx
    je block.117
    jmp block.118



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/complex_if_expr


# patch_instructions

	.align 16
conclusion:


	.align 16
block.116:
    movq %rdx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.117:
    movq $2, %rdx
    addq %rcx, %rdx
    jmp block.116

	.align 16
block.118:
    movq $10, %rdx
    addq %rcx, %rdx
    jmp block.116

	.align 16
block.119:
    cmpq $0, %rbx
    je block.117
    jmp block.118

	.align 16
start:
    callq read_int
    movq %rax, %rbx
    callq read_int
    movq %rax, %rcx
    cmpq $1, %rbx
    jl block.119
    cmpq $2, %rbx
    je block.117
    jmp block.118



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/complex_if_expr


# prelude_and_conclusion

	.align 16
conclusion:
    addq $8, %rsp
    popq %rbx
    popq %rbp
    retq 

	.align 16
block.116:
    movq %rdx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.117:
    movq $2, %rdx
    addq %rcx, %rdx
    jmp block.116

	.align 16
block.118:
    movq $10, %rdx
    addq %rcx, %rdx
    jmp block.116

	.align 16
block.119:
    cmpq $0, %rbx
    je block.117
    jmp block.118

	.align 16
start:
    callq read_int
    movq %rax, %rbx
    callq read_int
    movq %rax, %rcx
    cmpq $1, %rbx
    jl block.119
    cmpq $2, %rbx
    je block.117
    jmp block.118

	.globl main
	.align 16
main:
    pushq %rbp
    pushq %rbx
    movq %rsp, %rbp
    subq $8, %rsp
    jmp start





# source program: complex_p_with_ifs

    j = 8
    a = (-((4 if j == 2 else (j - 2))) if ((not(input_int() > 6) and input_int() < 127) or input_int() == 4) else (1 if (True if 2 < 4 else True) else 2))
    print(a)

Module([  Assign([Name('j')], Constant(8)),   Assign([Name('a')], IfExp(UnaryOp(Not(), Compare(Call(Name('input_int'), []), [Gt()], [Constant(6)])) And() Compare(Call(Name('input_int'), []), [Lt()], [Constant(127)]) Or() Compare(Call(Name('input_int'), []), [Eq()], [Constant(4)]), UnaryOp(USub(), IfExp(Compare(Name('j'), [Eq()], [Constant(2)]), Constant(4), BinOp(Name('j'), Sub(), Constant(2)))), IfExp(IfExp(Compare(Constant(2), [Lt()], [Constant(4)]), Constant(True), Constant(True)), Constant(1), Constant(2)))),   Expr(Call(Name('print'), [Name('a')]))])


# type checking source program


# partial_eval

    j = 8
    a = (-((4 if j == 2 else (j - 2))) if ((not(input_int() > 6) and input_int() < 127) or input_int() == 4) else 1)
    print(a)

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/complex_p_with_ifs


# shrink

    j = 8
    a = (-((4 if j == 2 else (j - 2))) if (True if (input_int() < 127 if not(input_int() > 6) else False) else input_int() == 4) else 1)
    print(a)

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/complex_p_with_ifs


# remove_complex_operands

    j = 8
    tmp.121 = input_int()
    tmp.122 = tmp.121 > 6
    a = ({
      tmp.125 = ({

        produce 4
} if j == 2 else {

        produce (j - 2)
})
      produce -(tmp.125)
} if ({

      produce True
} if ({
      tmp.123 = input_int()
      produce tmp.123 < 127
} if not(tmp.122) else {

      produce False
}) else {
      tmp.124 = input_int()
      produce tmp.124 == 4
}) else {

      produce 1
})
    print(a)
Module([  Assign([Name('j')], Constant(8)),   Assign([Name('tmp.121')], Call(Name('input_int'), [])),   Assign([Name('tmp.122')], Compare(Name('tmp.121'), [Gt()], [Constant(6)])),   Assign([Name('a')], IfExp(IfExp(IfExp(UnaryOp(Not(), Name('tmp.122')), Begin(body=[  Assign([Name('tmp.123')], Call(Name('input_int'), []))], result=Compare(Name('tmp.123'), [Lt()], [Constant(127)])), Begin(body=[], result=Constant(False))), Begin(body=[], result=Constant(True)), Begin(body=[  Assign([Name('tmp.124')], Call(Name('input_int'), []))], result=Compare(Name('tmp.124'), [Eq()], [Constant(4)]))), Begin(body=[  Assign([Name('tmp.125')], IfExp(Compare(Name('j'), [Eq()], [Constant(2)]), Begin(body=[], result=Constant(4)), Begin(body=[], result=BinOp(Name('j'), Sub(), Constant(2)))))], result=UnaryOp(USub(), Name('tmp.125'))), Begin(body=[], result=Constant(1)))),   Expr(Call(Name('print'), [Name('a')]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/complex_p_with_ifs


# explicate_control

block.126:
    print(a)
    return 0
block.127:
    a = -(tmp.125)
    goto block.126

block.128:
    tmp.125 = 4
    goto block.127

block.129:
    tmp.125 = (j - 2)
    goto block.127

block.130:
    if j == 2:
      goto block.128

    else:
      goto block.129

block.131:
    a = 1
    goto block.126

block.132:
    tmp.124 = input_int()
    if tmp.124 == 4:
      goto block.130

    else:
      goto block.131

block.133:
    tmp.123 = input_int()
    if tmp.123 < 127:
      goto block.130

    else:
      goto block.132

start:
    j = 8
    tmp.121 = input_int()
    tmp.122 = tmp.121 > 6
    if tmp.122 == False:
      goto block.133

    else:
      goto block.132


CProgram(body={'block.126': [  Expr(Call(Name('print'), [Name('a')])),   Return(Constant(0))], 'block.127': [  Assign([Name('a')], UnaryOp(USub(), Name('tmp.125'))), Goto(label='block.126')], 'block.128': [  Assign([Name('tmp.125')], Constant(4)), Goto(label='block.127')], 'block.129': [  Assign([Name('tmp.125')], BinOp(Name('j'), Sub(), Constant(2))), Goto(label='block.127')], 'block.130': [If(Compare(Name('j'), [Eq()], [Constant(2)]), [Goto(label='block.128')], [Goto(label='block.129')])], 'block.131': [  Assign([Name('a')], Constant(1)), Goto(label='block.126')], 'block.132': [  Assign([Name('tmp.124')], Call(Name('input_int'), [])), If(Compare(Name('tmp.124'), [Eq()], [Constant(4)]), [Goto(label='block.130')], [Goto(label='block.131')])], 'block.133': [  Assign([Name('tmp.123')], Call(Name('input_int'), [])), If(Compare(Name('tmp.123'), [Lt()], [Constant(127)]), [Goto(label='block.130')], [Goto(label='block.132')])], 'start': [  Assign([Name('j')], Constant(8)),   Assign([Name('tmp.121')], Call(Name('input_int'), [])),   Assign([Name('tmp.122')], Compare(Name('tmp.121'), [Gt()], [Constant(6)])), If(Compare(Name('tmp.122'), [Eq()], [Constant(False)]), [Goto(label='block.133')], [Goto(label='block.132')])]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/complex_p_with_ifs


# select_instructions

	.align 16
conclusion:


	.align 16
block.126:
    movq a, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.127:
    movq tmp.125, a
    negq a
    jmp block.126

	.align 16
block.128:
    movq $4, tmp.125
    jmp block.127

	.align 16
block.129:
    movq j, tmp.125
    subq $2, tmp.125
    jmp block.127

	.align 16
block.130:
    cmpq $2, j
    je block.128
    jmp block.129

	.align 16
block.131:
    movq $1, a
    jmp block.126

	.align 16
block.132:
    callq read_int
    movq %rax, tmp.124
    cmpq $4, tmp.124
    je block.130
    jmp block.131

	.align 16
block.133:
    callq read_int
    movq %rax, tmp.123
    cmpq $127, tmp.123
    jl block.130
    jmp block.132

	.align 16
start:
    movq $8, j
    callq read_int
    movq %rax, tmp.121
    cmpq $6, tmp.121
    setg %al
    movzbq %al, tmp.122
    cmpq $0, tmp.122
    je block.133
    jmp block.132



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/complex_p_with_ifs


# remove_jumps

	.align 16
conclusion:


	.align 16
block.126:
    movq a, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.127:
    movq tmp.125, a
    negq a
    jmp block.126

	.align 16
block.128:
    movq $4, tmp.125
    jmp block.127

	.align 16
block.130:
    cmpq $2, j
    je block.128
    movq j, tmp.125
    subq $2, tmp.125
    jmp block.127

	.align 16
block.132:
    callq read_int
    movq %rax, tmp.124
    cmpq $4, tmp.124
    je block.130
    movq $1, a
    jmp block.126

	.align 16
block.133:
    callq read_int
    movq %rax, tmp.123
    cmpq $127, tmp.123
    jl block.130
    jmp block.132

	.align 16
start:
    movq $8, j
    callq read_int
    movq %rax, tmp.121
    cmpq $6, tmp.121
    setg %al
    movzbq %al, tmp.122
    cmpq $0, tmp.122
    je block.133
    jmp block.132



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/complex_p_with_ifs


# assign_homes

	.align 16
conclusion:


	.align 16
block.126:
    movq %rbx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.127:
    movq %rbx, %rbx
    negq %rbx
    jmp block.126

	.align 16
block.128:
    movq $4, %rbx
    jmp block.127

	.align 16
block.130:
    cmpq $2, %rbx
    je block.128
    movq %rbx, %rbx
    subq $2, %rbx
    jmp block.127

	.align 16
block.132:
    callq read_int
    movq %rax, %rcx
    cmpq $4, %rcx
    je block.130
    movq $1, %rbx
    jmp block.126

	.align 16
block.133:
    callq read_int
    movq %rax, %rcx
    cmpq $127, %rcx
    jl block.130
    jmp block.132

	.align 16
start:
    movq $8, %rbx
    callq read_int
    movq %rax, %rcx
    cmpq $6, %rcx
    setg %al
    movzbq %al, %rcx
    cmpq $0, %rcx
    je block.133
    jmp block.132



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/complex_p_with_ifs


# patch_instructions

	.align 16
conclusion:


	.align 16
block.126:
    movq %rbx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.127:
    negq %rbx
    jmp block.126

	.align 16
block.128:
    movq $4, %rbx
    jmp block.127

	.align 16
block.130:
    cmpq $2, %rbx
    je block.128
    subq $2, %rbx
    jmp block.127

	.align 16
block.132:
    callq read_int
    movq %rax, %rcx
    cmpq $4, %rcx
    je block.130
    movq $1, %rbx
    jmp block.126

	.align 16
block.133:
    callq read_int
    movq %rax, %rcx
    cmpq $127, %rcx
    jl block.130
    jmp block.132

	.align 16
start:
    movq $8, %rbx
    callq read_int
    movq %rax, %rcx
    cmpq $6, %rcx
    setg %al
    movzbq %al, %rcx
    cmpq $0, %rcx
    je block.133
    jmp block.132



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/complex_p_with_ifs


# prelude_and_conclusion

	.align 16
conclusion:
    addq $8, %rsp
    popq %rbx
    popq %rbp
    retq 

	.align 16
block.126:
    movq %rbx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.127:
    negq %rbx
    jmp block.126

	.align 16
block.128:
    movq $4, %rbx
    jmp block.127

	.align 16
block.130:
    cmpq $2, %rbx
    je block.128
    subq $2, %rbx
    jmp block.127

	.align 16
block.132:
    callq read_int
    movq %rax, %rcx
    cmpq $4, %rcx
    je block.130
    movq $1, %rbx
    jmp block.126

	.align 16
block.133:
    callq read_int
    movq %rax, %rcx
    cmpq $127, %rcx
    jl block.130
    jmp block.132

	.align 16
start:
    movq $8, %rbx
    callq read_int
    movq %rax, %rcx
    cmpq $6, %rcx
    setg %al
    movzbq %al, %rcx
    cmpq $0, %rcx
    je block.133
    jmp block.132

	.globl main
	.align 16
main:
    pushq %rbp
    pushq %rbx
    movq %rsp, %rbp
    subq $8, %rsp
    jmp start





# source program: program_without_name

    if 5 > 10:
      print((1 if 2 == 2 else 3))
    else:

    if (5 > 6 if 6 < 110 else 110 == (10 + 100)):
      print(14)
    else:
      if ((True and (False if 5 == 10 else (True if 5 >= (-((6 - 118)) - 200) else False))) if True else False):
        print(1)
      else:
        print(2)

Module([If(Compare(Constant(5), [Gt()], [Constant(10)]), [  Expr(Call(Name('print'), [IfExp(Compare(Constant(2), [Eq()], [Constant(2)]), Constant(1), Constant(3))]))], []), If(IfExp(Compare(Constant(6), [Lt()], [Constant(110)]), Compare(Constant(5), [Gt()], [Constant(6)]), Compare(Constant(110), [Eq()], [BinOp(Constant(10), Add(), Constant(100))])), [  Expr(Call(Name('print'), [Constant(14)]))], [If(IfExp(Constant(True), Constant(True) And() IfExp(Compare(Constant(5), [Eq()], [Constant(10)]), Constant(False), IfExp(Compare(Constant(5), [GtE()], [BinOp(UnaryOp(USub(), BinOp(Constant(6), Sub(), Constant(118))), Sub(), Constant(200))]), Constant(True), Constant(False))), Constant(False)), [  Expr(Call(Name('print'), [Constant(1)]))], [  Expr(Call(Name('print'), [Constant(2)]))])])])


# type checking source program


# partial_eval

    print(1)

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/program_without_name


# shrink

    print(1)

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/program_without_name


# remove_complex_operands

    print(1)
Module([  Expr(Call(Name('print'), [Constant(1)]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/program_without_name


# explicate_control

start:
    print(1)
    return 0

CProgram(body={'start': [  Expr(Call(Name('print'), [Constant(1)])),   Return(Constant(0))]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/program_without_name


# select_instructions

	.align 16
conclusion:


	.align 16
start:
    movq $1, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/program_without_name


# remove_jumps

	.align 16
conclusion:


	.align 16
start:
    movq $1, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/program_without_name


# assign_homes

	.align 16
conclusion:


	.align 16
start:
    movq $1, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/program_without_name


# patch_instructions

	.align 16
conclusion:


	.align 16
start:
    movq $1, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/program_without_name


# prelude_and_conclusion

	.align 16
conclusion:
    popq %rbp
    retq 

	.align 16
start:
    movq $1, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.globl main
	.align 16
main:
    pushq %rbp
    movq %rsp, %rbp
    jmp start





# source program: test_not

    x = (input_int() + 15)
    y = -((4 - input_int()))
    if not(((x == y or not(x > y)) or not(not((5 - 4) > 6)))):
      x = (x - 1)
    else:
      y = (y + 1)
    print((x + y))

Module([  Assign([Name('x')], BinOp(Call(Name('input_int'), []), Add(), Constant(15))),   Assign([Name('y')], UnaryOp(USub(), BinOp(Constant(4), Sub(), Call(Name('input_int'), [])))), If(UnaryOp(Not(), Compare(Name('x'), [Eq()], [Name('y')]) Or() UnaryOp(Not(), Compare(Name('x'), [Gt()], [Name('y')])) Or() UnaryOp(Not(), UnaryOp(Not(), Compare(BinOp(Constant(5), Sub(), Constant(4)), [Gt()], [Constant(6)])))), [  Assign([Name('x')], BinOp(Name('x'), Sub(), Constant(1)))], [  Assign([Name('y')], BinOp(Name('y'), Add(), Constant(1)))]),   Expr(Call(Name('print'), [BinOp(Name('x'), Add(), Name('y'))]))])


# type checking source program


# partial_eval

    x = (15 + input_int())
    y = -((4 - input_int()))
    if not((x == y or not(x > y))):
      x = (x - 1)
    else:
      y = (1 + y)
    print((x + y))

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_not


# shrink

    x = (15 + input_int())
    y = -((4 - input_int()))
    if not((True if x == y else not(x > y))):
      x = (x - 1)
    else:
      y = (1 + y)
    print((x + y))

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_not


# remove_complex_operands

    tmp.134 = input_int()
    x = (15 + tmp.134)
    tmp.135 = input_int()
    tmp.136 = (4 - tmp.135)
    y = -(tmp.136)
    tmp.138 = ({

      produce True
} if x == y else {
      tmp.137 = x > y
      produce not(tmp.137)
})
    if not(tmp.138):
      x = (x - 1)
    else:
      y = (1 + y)
    tmp.139 = (x + y)
    print(tmp.139)
Module([  Assign([Name('tmp.134')], Call(Name('input_int'), [])),   Assign([Name('x')], BinOp(Constant(15), Add(), Name('tmp.134'))),   Assign([Name('tmp.135')], Call(Name('input_int'), [])),   Assign([Name('tmp.136')], BinOp(Constant(4), Sub(), Name('tmp.135'))),   Assign([Name('y')], UnaryOp(USub(), Name('tmp.136'))),   Assign([Name('tmp.138')], IfExp(Compare(Name('x'), [Eq()], [Name('y')]), Begin(body=[], result=Constant(True)), Begin(body=[  Assign([Name('tmp.137')], Compare(Name('x'), [Gt()], [Name('y')]))], result=UnaryOp(Not(), Name('tmp.137'))))), If(UnaryOp(Not(), Name('tmp.138')), [  Assign([Name('x')], BinOp(Name('x'), Sub(), Constant(1)))], [  Assign([Name('y')], BinOp(Constant(1), Add(), Name('y')))]),   Assign([Name('tmp.139')], BinOp(Name('x'), Add(), Name('y'))),   Expr(Call(Name('print'), [Name('tmp.139')]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_not


# explicate_control

block.140:
    tmp.139 = (x + y)
    print(tmp.139)
    return 0
block.141:
    x = (x - 1)
    goto block.140

block.142:
    y = (1 + y)
    goto block.140

block.143:
    if tmp.138 == False:
      goto block.141

    else:
      goto block.142

block.144:
    tmp.138 = True
    goto block.143

block.145:
    tmp.137 = x > y
    tmp.138 = not(tmp.137)
    goto block.143

start:
    tmp.134 = input_int()
    x = (15 + tmp.134)
    tmp.135 = input_int()
    tmp.136 = (4 - tmp.135)
    y = -(tmp.136)
    if x == y:
      goto block.144

    else:
      goto block.145


CProgram(body={'block.140': [  Assign([Name('tmp.139')], BinOp(Name('x'), Add(), Name('y'))),   Expr(Call(Name('print'), [Name('tmp.139')])),   Return(Constant(0))], 'block.141': [  Assign([Name('x')], BinOp(Name('x'), Sub(), Constant(1))), Goto(label='block.140')], 'block.142': [  Assign([Name('y')], BinOp(Constant(1), Add(), Name('y'))), Goto(label='block.140')], 'block.143': [If(Compare(Name('tmp.138'), [Eq()], [Constant(False)]), [Goto(label='block.141')], [Goto(label='block.142')])], 'block.144': [  Assign([Name('tmp.138')], Constant(True)), Goto(label='block.143')], 'block.145': [  Assign([Name('tmp.137')], Compare(Name('x'), [Gt()], [Name('y')])),   Assign([Name('tmp.138')], UnaryOp(Not(), Name('tmp.137'))), Goto(label='block.143')], 'start': [  Assign([Name('tmp.134')], Call(Name('input_int'), [])),   Assign([Name('x')], BinOp(Constant(15), Add(), Name('tmp.134'))),   Assign([Name('tmp.135')], Call(Name('input_int'), [])),   Assign([Name('tmp.136')], BinOp(Constant(4), Sub(), Name('tmp.135'))),   Assign([Name('y')], UnaryOp(USub(), Name('tmp.136'))), If(Compare(Name('x'), [Eq()], [Name('y')]), [Goto(label='block.144')], [Goto(label='block.145')])]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_not


# select_instructions

	.align 16
conclusion:


	.align 16
block.140:
    movq x, tmp.139
    addq y, tmp.139
    movq tmp.139, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.141:
    subq $1, x
    jmp block.140

	.align 16
block.142:
    addq $1, y
    jmp block.140

	.align 16
block.143:
    cmpq $0, tmp.138
    je block.141
    jmp block.142

	.align 16
block.144:
    movq $1, tmp.138
    jmp block.143

	.align 16
block.145:
    cmpq y, x
    setg %al
    movzbq %al, tmp.137
    movq tmp.137, tmp.138
    xorq $1, tmp.138
    jmp block.143

	.align 16
start:
    callq read_int
    movq %rax, tmp.134
    movq $15, x
    addq tmp.134, x
    callq read_int
    movq %rax, tmp.135
    movq $4, tmp.136
    subq tmp.135, tmp.136
    movq tmp.136, y
    negq y
    cmpq y, x
    je block.144
    jmp block.145



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_not


# remove_jumps

	.align 16
conclusion:


	.align 16
block.140:
    movq x, tmp.139
    addq y, tmp.139
    movq tmp.139, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.141:
    subq $1, x
    jmp block.140

	.align 16
block.143:
    cmpq $0, tmp.138
    je block.141
    addq $1, y
    jmp block.140

	.align 16
block.144:
    movq $1, tmp.138
    jmp block.143

	.align 16
start:
    callq read_int
    movq %rax, tmp.134
    movq $15, x
    addq tmp.134, x
    callq read_int
    movq %rax, tmp.135
    movq $4, tmp.136
    subq tmp.135, tmp.136
    movq tmp.136, y
    negq y
    cmpq y, x
    je block.144
    cmpq y, x
    setg %al
    movzbq %al, tmp.137
    movq tmp.137, tmp.138
    xorq $1, tmp.138
    jmp block.143



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_not


# assign_homes

	.align 16
conclusion:


	.align 16
block.140:
    movq %rbx, %rbx
    addq %rcx, %rbx
    movq %rbx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.141:
    subq $1, %rbx
    jmp block.140

	.align 16
block.143:
    cmpq $0, %rdx
    je block.141
    addq $1, %rcx
    jmp block.140

	.align 16
block.144:
    movq $1, %rdx
    jmp block.143

	.align 16
start:
    callq read_int
    movq %rax, %rcx
    movq $15, %rbx
    addq %rcx, %rbx
    callq read_int
    movq %rax, %rdx
    movq $4, %rcx
    subq %rdx, %rcx
    movq %rcx, %rcx
    negq %rcx
    cmpq %rcx, %rbx
    je block.144
    cmpq %rcx, %rbx
    setg %al
    movzbq %al, %rdx
    movq %rdx, %rdx
    xorq $1, %rdx
    jmp block.143



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_not


# patch_instructions

	.align 16
conclusion:


	.align 16
block.140:
    addq %rcx, %rbx
    movq %rbx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.141:
    subq $1, %rbx
    jmp block.140

	.align 16
block.143:
    cmpq $0, %rdx
    je block.141
    addq $1, %rcx
    jmp block.140

	.align 16
block.144:
    movq $1, %rdx
    jmp block.143

	.align 16
start:
    callq read_int
    movq %rax, %rcx
    movq $15, %rbx
    addq %rcx, %rbx
    callq read_int
    movq %rax, %rdx
    movq $4, %rcx
    subq %rdx, %rcx
    negq %rcx
    cmpq %rcx, %rbx
    je block.144
    cmpq %rcx, %rbx
    setg %al
    movzbq %al, %rdx
    xorq $1, %rdx
    jmp block.143



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_not


# prelude_and_conclusion

	.align 16
conclusion:
    addq $8, %rsp
    popq %rbx
    popq %rbp
    retq 

	.align 16
block.140:
    addq %rcx, %rbx
    movq %rbx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.141:
    subq $1, %rbx
    jmp block.140

	.align 16
block.143:
    cmpq $0, %rdx
    je block.141
    addq $1, %rcx
    jmp block.140

	.align 16
block.144:
    movq $1, %rdx
    jmp block.143

	.align 16
start:
    callq read_int
    movq %rax, %rcx
    movq $15, %rbx
    addq %rcx, %rbx
    callq read_int
    movq %rax, %rdx
    movq $4, %rcx
    subq %rdx, %rcx
    negq %rcx
    cmpq %rcx, %rbx
    je block.144
    cmpq %rcx, %rbx
    setg %al
    movzbq %al, %rdx
    xorq $1, %rdx
    jmp block.143

	.globl main
	.align 16
main:
    pushq %rbp
    pushq %rbx
    movq %rsp, %rbp
    subq $8, %rsp
    jmp start





# source program: test_inplace_not

    a = input_int() == 0
    b = input_int() == 1
    a = not(a)
    b = not(a)
    c = (not(a) and not(b))
    d = (not(a) or not(b))
    d = not(d)
    c = not(d)
    print((1 if c == True else 0))

Module([  Assign([Name('a')], Compare(Call(Name('input_int'), []), [Eq()], [Constant(0)])),   Assign([Name('b')], Compare(Call(Name('input_int'), []), [Eq()], [Constant(1)])),   Assign([Name('a')], UnaryOp(Not(), Name('a'))),   Assign([Name('b')], UnaryOp(Not(), Name('a'))),   Assign([Name('c')], UnaryOp(Not(), Name('a')) And() UnaryOp(Not(), Name('b'))),   Assign([Name('d')], UnaryOp(Not(), Name('a')) Or() UnaryOp(Not(), Name('b'))),   Assign([Name('d')], UnaryOp(Not(), Name('d'))),   Assign([Name('c')], UnaryOp(Not(), Name('d'))),   Expr(Call(Name('print'), [IfExp(Compare(Name('c'), [Eq()], [Constant(True)]), Constant(1), Constant(0))]))])


# type checking source program


# partial_eval

    a = input_int() == 0
    b = input_int() == 1
    a = not(a)
    b = not(a)
    c = (not(a) and not(b))
    d = (not(a) or not(b))
    d = not(d)
    c = not(d)
    print((1 if c else 0))

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_inplace_not


# shrink

    a = input_int() == 0
    b = input_int() == 1
    a = not(a)
    b = not(a)
    c = (not(b) if not(a) else False)
    d = (True if not(a) else not(b))
    d = not(d)
    c = not(d)
    print((1 if c else 0))

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_inplace_not


# remove_complex_operands

    tmp.146 = input_int()
    a = tmp.146 == 0
    tmp.147 = input_int()
    b = tmp.147 == 1
    a = not(a)
    b = not(a)
    c = ({

      produce not(b)
} if not(a) else {

      produce False
})
    d = ({

      produce True
} if not(a) else {

      produce not(b)
})
    d = not(d)
    c = not(d)
    tmp.148 = ({

      produce 1
} if c else {

      produce 0
})
    print(tmp.148)
Module([  Assign([Name('tmp.146')], Call(Name('input_int'), [])),   Assign([Name('a')], Compare(Name('tmp.146'), [Eq()], [Constant(0)])),   Assign([Name('tmp.147')], Call(Name('input_int'), [])),   Assign([Name('b')], Compare(Name('tmp.147'), [Eq()], [Constant(1)])),   Assign([Name('a')], UnaryOp(Not(), Name('a'))),   Assign([Name('b')], UnaryOp(Not(), Name('a'))),   Assign([Name('c')], IfExp(UnaryOp(Not(), Name('a')), Begin(body=[], result=UnaryOp(Not(), Name('b'))), Begin(body=[], result=Constant(False)))),   Assign([Name('d')], IfExp(UnaryOp(Not(), Name('a')), Begin(body=[], result=Constant(True)), Begin(body=[], result=UnaryOp(Not(), Name('b'))))),   Assign([Name('d')], UnaryOp(Not(), Name('d'))),   Assign([Name('c')], UnaryOp(Not(), Name('d'))),   Assign([Name('tmp.148')], IfExp(Name('c'), Begin(body=[], result=Constant(1)), Begin(body=[], result=Constant(0)))),   Expr(Call(Name('print'), [Name('tmp.148')]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_inplace_not


# explicate_control

block.149:
    print(tmp.148)
    return 0
block.150:
    tmp.148 = 0
    goto block.149

block.151:
    tmp.148 = 1
    goto block.149

block.152:
    d = not(d)
    c = not(d)
    if c == False:
      goto block.150

    else:
      goto block.151

block.153:
    d = True
    goto block.152

block.154:
    d = not(b)
    goto block.152

block.155:
    if a == False:
      goto block.153

    else:
      goto block.154

block.156:
    c = not(b)
    goto block.155

block.157:
    c = False
    goto block.155

start:
    tmp.146 = input_int()
    a = tmp.146 == 0
    tmp.147 = input_int()
    b = tmp.147 == 1
    a = not(a)
    b = not(a)
    if a == False:
      goto block.156

    else:
      goto block.157


CProgram(body={'block.149': [  Expr(Call(Name('print'), [Name('tmp.148')])),   Return(Constant(0))], 'block.150': [  Assign([Name('tmp.148')], Constant(0)), Goto(label='block.149')], 'block.151': [  Assign([Name('tmp.148')], Constant(1)), Goto(label='block.149')], 'block.152': [  Assign([Name('d')], UnaryOp(Not(), Name('d'))),   Assign([Name('c')], UnaryOp(Not(), Name('d'))), If(Compare(Name('c'), [Eq()], [Constant(False)]), [Goto(label='block.150')], [Goto(label='block.151')])], 'block.153': [  Assign([Name('d')], Constant(True)), Goto(label='block.152')], 'block.154': [  Assign([Name('d')], UnaryOp(Not(), Name('b'))), Goto(label='block.152')], 'block.155': [If(Compare(Name('a'), [Eq()], [Constant(False)]), [Goto(label='block.153')], [Goto(label='block.154')])], 'block.156': [  Assign([Name('c')], UnaryOp(Not(), Name('b'))), Goto(label='block.155')], 'block.157': [  Assign([Name('c')], Constant(False)), Goto(label='block.155')], 'start': [  Assign([Name('tmp.146')], Call(Name('input_int'), [])),   Assign([Name('a')], Compare(Name('tmp.146'), [Eq()], [Constant(0)])),   Assign([Name('tmp.147')], Call(Name('input_int'), [])),   Assign([Name('b')], Compare(Name('tmp.147'), [Eq()], [Constant(1)])),   Assign([Name('a')], UnaryOp(Not(), Name('a'))),   Assign([Name('b')], UnaryOp(Not(), Name('a'))), If(Compare(Name('a'), [Eq()], [Constant(False)]), [Goto(label='block.156')], [Goto(label='block.157')])]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_inplace_not


# select_instructions

	.align 16
conclusion:


	.align 16
block.149:
    movq tmp.148, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.150:
    movq $0, tmp.148
    jmp block.149

	.align 16
block.151:
    movq $1, tmp.148
    jmp block.149

	.align 16
block.152:
    xorq $1, d
    movq d, c
    xorq $1, c
    cmpq $0, c
    je block.150
    jmp block.151

	.align 16
block.153:
    movq $1, d
    jmp block.152

	.align 16
block.154:
    movq b, d
    xorq $1, d
    jmp block.152

	.align 16
block.155:
    cmpq $0, a
    je block.153
    jmp block.154

	.align 16
block.156:
    movq b, c
    xorq $1, c
    jmp block.155

	.align 16
block.157:
    movq $0, c
    jmp block.155

	.align 16
start:
    callq read_int
    movq %rax, tmp.146
    cmpq $0, tmp.146
    sete %al
    movzbq %al, a
    callq read_int
    movq %rax, tmp.147
    cmpq $1, tmp.147
    sete %al
    movzbq %al, b
    xorq $1, a
    movq a, b
    xorq $1, b
    cmpq $0, a
    je block.156
    jmp block.157



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_inplace_not


# remove_jumps

	.align 16
conclusion:


	.align 16
block.149:
    movq tmp.148, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.150:
    movq $0, tmp.148
    jmp block.149

	.align 16
block.152:
    xorq $1, d
    movq d, c
    xorq $1, c
    cmpq $0, c
    je block.150
    movq $1, tmp.148
    jmp block.149

	.align 16
block.153:
    movq $1, d
    jmp block.152

	.align 16
block.155:
    cmpq $0, a
    je block.153
    movq b, d
    xorq $1, d
    jmp block.152

	.align 16
block.156:
    movq b, c
    xorq $1, c
    jmp block.155

	.align 16
start:
    callq read_int
    movq %rax, tmp.146
    cmpq $0, tmp.146
    sete %al
    movzbq %al, a
    callq read_int
    movq %rax, tmp.147
    cmpq $1, tmp.147
    sete %al
    movzbq %al, b
    xorq $1, a
    movq a, b
    xorq $1, b
    cmpq $0, a
    je block.156
    movq $0, c
    jmp block.155



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_inplace_not


# assign_homes

	.align 16
conclusion:


	.align 16
block.149:
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.150:
    movq $0, %rcx
    jmp block.149

	.align 16
block.152:
    xorq $1, %rcx
    movq %rcx, %rcx
    xorq $1, %rcx
    cmpq $0, %rcx
    je block.150
    movq $1, %rcx
    jmp block.149

	.align 16
block.153:
    movq $1, %rcx
    jmp block.152

	.align 16
block.155:
    cmpq $0, %rbx
    je block.153
    movq %rdx, %rcx
    xorq $1, %rcx
    jmp block.152

	.align 16
block.156:
    movq %rdx, %rcx
    xorq $1, %rcx
    jmp block.155

	.align 16
start:
    callq read_int
    movq %rax, %rcx
    cmpq $0, %rcx
    sete %al
    movzbq %al, %rbx
    callq read_int
    movq %rax, %rcx
    cmpq $1, %rcx
    sete %al
    movzbq %al, %rdx
    xorq $1, %rbx
    movq %rbx, %rdx
    xorq $1, %rdx
    cmpq $0, %rbx
    je block.156
    movq $0, %rcx
    jmp block.155



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_inplace_not


# patch_instructions

	.align 16
conclusion:


	.align 16
block.149:
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.150:
    movq $0, %rcx
    jmp block.149

	.align 16
block.152:
    xorq $1, %rcx
    xorq $1, %rcx
    cmpq $0, %rcx
    je block.150
    movq $1, %rcx
    jmp block.149

	.align 16
block.153:
    movq $1, %rcx
    jmp block.152

	.align 16
block.155:
    cmpq $0, %rbx
    je block.153
    movq %rdx, %rcx
    xorq $1, %rcx
    jmp block.152

	.align 16
block.156:
    movq %rdx, %rcx
    xorq $1, %rcx
    jmp block.155

	.align 16
start:
    callq read_int
    movq %rax, %rcx
    cmpq $0, %rcx
    sete %al
    movzbq %al, %rbx
    callq read_int
    movq %rax, %rcx
    cmpq $1, %rcx
    sete %al
    movzbq %al, %rdx
    xorq $1, %rbx
    movq %rbx, %rdx
    xorq $1, %rdx
    cmpq $0, %rbx
    je block.156
    movq $0, %rcx
    jmp block.155



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_inplace_not


# prelude_and_conclusion

	.align 16
conclusion:
    addq $8, %rsp
    popq %rbx
    popq %rbp
    retq 

	.align 16
block.149:
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.150:
    movq $0, %rcx
    jmp block.149

	.align 16
block.152:
    xorq $1, %rcx
    xorq $1, %rcx
    cmpq $0, %rcx
    je block.150
    movq $1, %rcx
    jmp block.149

	.align 16
block.153:
    movq $1, %rcx
    jmp block.152

	.align 16
block.155:
    cmpq $0, %rbx
    je block.153
    movq %rdx, %rcx
    xorq $1, %rcx
    jmp block.152

	.align 16
block.156:
    movq %rdx, %rcx
    xorq $1, %rcx
    jmp block.155

	.align 16
start:
    callq read_int
    movq %rax, %rcx
    cmpq $0, %rcx
    sete %al
    movzbq %al, %rbx
    callq read_int
    movq %rax, %rcx
    cmpq $1, %rcx
    sete %al
    movzbq %al, %rdx
    xorq $1, %rbx
    movq %rbx, %rdx
    xorq $1, %rdx
    cmpq $0, %rbx
    je block.156
    movq $0, %rcx
    jmp block.155

	.globl main
	.align 16
main:
    pushq %rbp
    pushq %rbx
    movq %rsp, %rbp
    subq $8, %rsp
    jmp start





# source program: test_5

    print((42 if input_int() == 1 else 0))

Module([  Expr(Call(Name('print'), [IfExp(Compare(Call(Name('input_int'), []), [Eq()], [Constant(1)]), Constant(42), Constant(0))]))])


# type checking source program


# partial_eval

    print((42 if input_int() == 1 else 0))

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_5


# shrink

    print((42 if input_int() == 1 else 0))

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_5


# remove_complex_operands

    tmp.158 = input_int()
    tmp.159 = ({

      produce 42
} if tmp.158 == 1 else {

      produce 0
})
    print(tmp.159)
Module([  Assign([Name('tmp.158')], Call(Name('input_int'), [])),   Assign([Name('tmp.159')], IfExp(Compare(Name('tmp.158'), [Eq()], [Constant(1)]), Begin(body=[], result=Constant(42)), Begin(body=[], result=Constant(0)))),   Expr(Call(Name('print'), [Name('tmp.159')]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_5


# explicate_control

block.160:
    print(tmp.159)
    return 0
block.161:
    tmp.159 = 42
    goto block.160

block.162:
    tmp.159 = 0
    goto block.160

start:
    tmp.158 = input_int()
    if tmp.158 == 1:
      goto block.161

    else:
      goto block.162


CProgram(body={'block.160': [  Expr(Call(Name('print'), [Name('tmp.159')])),   Return(Constant(0))], 'block.161': [  Assign([Name('tmp.159')], Constant(42)), Goto(label='block.160')], 'block.162': [  Assign([Name('tmp.159')], Constant(0)), Goto(label='block.160')], 'start': [  Assign([Name('tmp.158')], Call(Name('input_int'), [])), If(Compare(Name('tmp.158'), [Eq()], [Constant(1)]), [Goto(label='block.161')], [Goto(label='block.162')])]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_5


# select_instructions

	.align 16
conclusion:


	.align 16
block.160:
    movq tmp.159, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.161:
    movq $42, tmp.159
    jmp block.160

	.align 16
block.162:
    movq $0, tmp.159
    jmp block.160

	.align 16
start:
    callq read_int
    movq %rax, tmp.158
    cmpq $1, tmp.158
    je block.161
    jmp block.162



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_5


# remove_jumps

	.align 16
conclusion:


	.align 16
block.160:
    movq tmp.159, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.161:
    movq $42, tmp.159
    jmp block.160

	.align 16
start:
    callq read_int
    movq %rax, tmp.158
    cmpq $1, tmp.158
    je block.161
    movq $0, tmp.159
    jmp block.160



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_5


# assign_homes

	.align 16
conclusion:


	.align 16
block.160:
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.161:
    movq $42, %rcx
    jmp block.160

	.align 16
start:
    callq read_int
    movq %rax, %rcx
    cmpq $1, %rcx
    je block.161
    movq $0, %rcx
    jmp block.160



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_5


# patch_instructions

	.align 16
conclusion:


	.align 16
block.160:
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.161:
    movq $42, %rcx
    jmp block.160

	.align 16
start:
    callq read_int
    movq %rax, %rcx
    cmpq $1, %rcx
    je block.161
    movq $0, %rcx
    jmp block.160



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_5


# prelude_and_conclusion

	.align 16
conclusion:
    popq %rbp
    retq 

	.align 16
block.160:
    movq %rcx, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.align 16
block.161:
    movq $42, %rcx
    jmp block.160

	.align 16
start:
    callq read_int
    movq %rax, %rcx
    cmpq $1, %rcx
    je block.161
    movq $0, %rcx
    jmp block.160

	.globl main
	.align 16
main:
    pushq %rbp
    movq %rsp, %rbp
    jmp start





# source program: test_redunant_blocks

    if True:
      print(0)
    else:
      x = (1 if False else 2)      print(x)

Module([If(Constant(True), [  Expr(Call(Name('print'), [Constant(0)]))], [  Assign([Name('x')], IfExp(Constant(False), Constant(1), Constant(2))),   Expr(Call(Name('print'), [Name('x')]))])])


# type checking source program


# partial_eval

    print(0)

compiler var success on pass partial_eval on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_redunant_blocks


# shrink

    print(0)

compiler var success on pass shrink on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_redunant_blocks


# remove_complex_operands

    print(0)
Module([  Expr(Call(Name('print'), [Constant(0)]))])
type checking after remove_complex_operands

type checking passed
compiler var success on pass remove_complex_operands on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_redunant_blocks


# explicate_control

start:
    print(0)
    return 0

CProgram(body={'start': [  Expr(Call(Name('print'), [Constant(0)])),   Return(Constant(0))]})
skipped type checking
compiler var success on pass explicate_control on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_redunant_blocks


# select_instructions

	.align 16
conclusion:


	.align 16
start:
    movq $0, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass select_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_redunant_blocks


# remove_jumps

	.align 16
conclusion:


	.align 16
start:
    movq $0, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass remove_jumps on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_redunant_blocks


# assign_homes

	.align 16
conclusion:


	.align 16
start:
    movq $0, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass assign_homes on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_redunant_blocks


# patch_instructions

	.align 16
conclusion:


	.align 16
start:
    movq $0, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion



compiler var success on pass patch_instructions on test
/home/joe/dev/essentials_of_compilation_on_support/tests/var/test_redunant_blocks


# prelude_and_conclusion

	.align 16
conclusion:
    popq %rbp
    retq 

	.align 16
start:
    movq $0, %rdi
    callq print_int
    movq $0, %rax
    jmp conclusion

	.globl main
	.align 16
main:
    pushq %rbp
    movq %rsp, %rbp
    jmp start




